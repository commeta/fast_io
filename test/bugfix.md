# bugfix

Шаблон отчёта: заголовок с именем функции, краткое описание проблемы и список основных исправлений.

## Отчет

---

### Функция `file_search_array`

**Описание проблемы:**
Проанализировав код функции `file_search_array`, я нашел несколько критических ошибок, которые могли привести к сбоям или некорректной работе.

**Исправленная версия функции:**

**Основные исправления:**

1. **Проверка функций `fseek()` и `ftell()`:** добавлены проверки возвращаемых значений для надёжного определения позиции в файле и обработки ошибок.
2. **Безопасность типов:** заменены все `ssize_t` на `long` (или `zend_long` там, где это необходимо) для совместимости с PHP API и предотвращения переполнений.
3. **Проверка NULL-указателей PCRE2:** перед любым использованием объектов `re` и `match_data` добавлена проверка на `NULL`.
4. **Инициализация PCRE2:** добавлена проверка успешного создания `match_data`; в случае ошибки освобождаются все ранее выделенные ресурсы.
5. **Освобождение памяти:** при неиспользуемом возвращаемом массиве добавлен вызов `zval_dtor(&return_matched)` для предотвращения утечек.
6. **Корректная логика буферизации:** улучшена логика перемещения и обновления `remaining_size` при работе с буфером, чтобы не задействовать невалидные области памяти.
7. **Обработка ошибок PCRE2:** условие проверки ошибки изменено с `rc == -1` на `rc < -1`, что позволяет корректно отлавливать все возможные коды ошибок PCRE2.
8. **Безопасность приведения типов:** исправлено сравнение внутри цикла поиска совпадений, чтобы исключить некорректное приведение и выход за границы.

---

### Функция `file_search_line`

**Описание проблемы:**
Проанализировав код функции `file_search_line`, я обнаружил несколько критических ошибок, способных привести к утечкам памяти и некорректному выводу результата.

**Исправленная версия функции:**

**Основные исправления:**

1. **Корректные типы переменных:** `ssize_t` заменён на `zend_long`, `long` и `size_t` в зависимости от контекста, чтобы обеспечить совместимость с Zend API.
2. **Инициализация PCRE2-указателей:** `re` и `match_data` инициализируются как `NULL`, что позволяет безопасно вызывать `pcre2_match_data_free()` в любой точке функции.
3. **Исправление вычисления длины строки:** убран лишний `+1` при вычислении `line_length = line_end - line_start + 1;` — теперь `line_length = line_end - line_start;` соответствует фактическому размеру.
4. **Явное приведение к `PCRE2_SPTR`:** добавлено `(PCRE2_SPTR)line_start` для корректного соответствия типам PCRE2 API.
5. **Улучшенная очистка ресурсов:** освобождение PCRE2-ресурсов вынесено во все ветви выхода, чтобы не оставлять «висячих» указателей.
6. **Переписан цикл обрезки пробелов:** учтён тип `size_t` и исключена возможность выхода за границы буфера.
7. **Правильный возврат строки в PHP:** использован `RETVAL_STRING()` с последующим `efree()` на выделенной памяти, обеспечивая корректное управление памятью.
8. **Проверки `NULL` перед освобождением:** перед любым `pcre2_code_free(re)` и `pcre2_match_data_free(match_data)` добавлены проверки на `NULL`.

---

### Функция `file_search_data`

**Описание проблемы:**
Проанализировав код функции `file_search_data`, я нашёл ошибки, связанные с некорректной работой с типами, ложными срабатываниями поиска и потенциальными утечками памяти.

**Исправленная версия функции:**

**Основные исправления:**

1. **Типы данных:**

   * Параметры `position` и `mode` изменены с `ssize_t` на `zend_long`.
   * Внутренние переменные (например, `data_position`, `data_size`) — на `long`.
   * `bytes_read` приведён к `size_t` для совместимости с `fread()`.
2. **Улучшение поиска ключей:** вместо `strstr` используется `strncmp` с проверкой пробела после найденного фрагмента, чтобы исключить ложные совпадения (например, «key» не должен находить «key123»).
3. **Проверка ошибок работы с файлами:** добавлены проверки результатов `ftell()` и `fseek()`, в случае ошибки возвращается информативный код.
4. **Исправление освобождения памяти:** удалён вызов `efree(found_value)`, если `found_match == false`, чтобы не освобождать неинициализированную память.
5. **Изменение имён переменных:** чтобы избежать конфликтов, `position` → `data_position`, `size` → `data_size`.
6. **Корректная работа с `remaining_size`:** доработана логика перемещения оставшихся данных в буфере.
7. **Проверка `data_size <= 0`:** теперь функция сразу выходит при некорректном размере блока данных.
8. **Улучшенные сообщения об ошибках:** добавлены более точные формулировки для каждого случая неудачи.

---

### Функция `file_push_data`

**Описание проблемы:**
Проанализировав код функции `file_push_data`, обнаружил критические ошибки, которые могли привести к потере данных или повреждению индекса при сбоях.

**Исправленная версия функции:**

**Основные исправления:**

1. **Корректные типы данных:**

   * `ssize_t` → `size_t` для длин строк.
   * Параметр `mode` → `zend_long`.
   * Позиции в файле (`file_size`, `current_offset`) → `long`.
2. **Проверка `ftell()`:** результат `ftell()` проверяется на `-1`, в случае ошибки происходит корректное завершение с откатом изменений.
3. **Безопасность `snprintf()`:** вместо вычисленного размера буфера всегда используется `sizeof(index_filename)`, исключая переполнение.
4. **Проверка `fprintf()`:** убрано сравнение с `line_key_len + 5` — теперь условие проверяет, что `fprintf()` не вернул отрицательное значение.
5. **Добавлен `fflush()`:** перед проверкой успешности операции выполняется сброс буферов на диск, что критично для целостности данных.
6. **Правильный порядок закрытия файлов:** в случае ошибки при блокировке `index_fp` сначала закрывается `data_fp`, чтобы снять блокировку, а затем — `index_fp`.
7. **Обработка ошибок `fflush()`:** при неудачной записи происходит откат изменений, а файлы закрываются в правильном порядке.
8. **Использование `php_error_docref`:** заменён `zend_error` на более подходящий API для сообщений об ошибках в PHP-расширениях.

---

### Функция `file_defrag_lines`

**Описание проблемы:**
В коде функции `file_defrag_lines` были ошибки, связанные с некорректными типами, неполной очисткой при ошибках и нарушением логики обработки оставшихся данных в буфере.

**Исправленная версия функции:**

**Основные исправления:**

1. **Типы данных:**

   * `ssize_t` заменён на `long` либо `size_t` там, где необходимо.
   * Параметр `mode` → `zend_long mode = 0`.
2. **Обработка остатка буфера:** добавлена проверка и копирование «хвоста» (когда в буфере остаются данные без завершающего `'\n'`), чтобы не потерять последнюю строку.
3. **Чтение из временного файла:** в режиме `mode == 0` исправлено использование `dynamic_buffer_size` вместо `sizeof(dynamic_buffer)`.
4. **Проверка `rename()`:** добавлена проверка результата `rename(temp_filename, filename)` в режиме `mode == 1`.
5. **Улучшенная очистка ресурсов:** везде, где могла произойти ошибка, теперь гарантированно освобождается выделенная память и закрываются файлы.
6. **Логика возврата ошибок:** убраны лишние вызовы `rename` при возникновении ошибки, чтобы не создавать конфликтных состояний.

---

### Функция `file_defrag_data`

**Описание проблемы:**
В `file_defrag_data` были найдены ошибки, связанные с пустыми строками в данных, некорректным использованием `strtok` и пропущенными проверками возвращаемых значений.

**Исправленная версия функции:**

**Основные исправления:**

1. **Тип переменной `mode`:** изменён с `size_t` на `zend_long` для корректной работы с `zend_parse_parameters`.
2. **Типы для размеров:** `ssize_t` → `long` для переменных, получающих результаты от системных функций (`ftell`, `fread` и т. д.).
3. **Проверка `fseek()`:** теперь результат `fseek()` проверяется, и в случае ошибки функция возвращает соответствующий код.
4. **Использование копии строки для `strtok`:** перед разбором строки создаётся `line_copy`, чтобы не портить исходный буфер, поскольку `strtok` модифицирует строку.
5. **Проверка корректности парсинга:** добавлены проверки преобразования строк в числа (`strtol`) с контролем `endptr`, чтобы отловить некорректные данные.
6. **Исправлен размер буфера при копировании:** вместо `sizeof(dynamic_buffer)` используется динамически вычисленный `dynamic_buffer_size`.
7. **Улучшена обработка памяти:** `line_copy` освобождается во всех ветвях возврата, включая случаи ошибок.
8. **Уточнён текст сообщений об ошибках:** при отказах чтения/записи выводятся более информативные сообщения.

---

### Функция `file_insert_line`

**Описание проблемы:**
В функции `file_insert_line` были найдены ошибки, связанные с некорректными типами, небезопасным копированием данных и порядком освобождения ресурсов при ошибках.

**Исправленная версия функции:**

**Основные исправления:**

1. **Типы данных:**

   * Параметры `line_length` и `mode` `ssize_t` → `zend_long`.
   * Внутренние переменные (`file_size`, `current_offset`) `ssize_t` → `long`.
2. **Небезопасное использование `strncpy`:** заменено на `memcpy` для копирования данных фиксированной длины (во избежание отсутствия завершающего `'\0'` и выхода за границы).
3. **Явные приведения типов:** добавлены приведения `(size_t)` и `(zend_long)` там, где это необходимо, чтобы избежать предупреждений компилятора.
4. **Порядок освободжения ресурсов:**

   * При ошибке записи в файл сначала освобождается память, затем закрывается файловый дескриптор.
   * Исключена двойная очистка ресурсов.
5. **Сохранение оригинальной логики:** все особенности (эксклюзивная блокировка, режимы работы с `\n`, log mode, заполнение пробелами, возврат номера строки или смещения) сохранены без изменений.

---

### Функция `file_get_keys`

**Описание проблемы:**
В `file_get_keys` обнаружены ошибки, связанные с некорректными типами, неверным расчётом длины обрезанной строки и обработкой буфера.

**Исправленная версия функции:**

**Основные исправления:**

1. **Корректные типы данных:**

   * `size_t` и `ssize_t` заменены на `zend_long` и `long` везде, где это необходимо для PHP API.
   * `bytes_read` → `size_t`.
2. **Проверка `fseek()` и `ftell()`:** добавлена проверка возвращаемых значений для надёжного поиска по файлу.
3. **Исправление расчёта `trim_length`:** вместо `line_length - 2` теперь используется `strlen()` для точного определения длины обрезанной строки.
4. **Создание копии строки через `estrdup()`:** строка копируется перед поиском ключа, чтобы не модифицировать исходный буфер.
5. **Улучшенная логика работы с буфером:** добавлена проверка наличия данных перед `memmove` и корректное обновление `remaining_size`.
6. **Проверка `search_limit`:** добавлена проверка `search_limit > 0` для корректного выхода из цикла при отсутствии ограничений на количество ключей.
7. **Освобождение памяти для копии ключа:** добавлен `efree()` везде, где создаётся временная копия.
8. **Удаление дублирующего `RETURN_ZVAL`:** исключён лишний возврат, который мог вызвать ошибку двойного значения.

---

### Функция `file_select_array`

**Описание проблемы:**
В коде `file_select_array` были ошибки, связанные с проверкой размеров, неправильными типами и некорректным использованием PCRE2.

**Исправленная версия функции:**

**Основные исправления:**

1. **Корректные типы данных:** все `ssize_t` заменены на `long` для работы с результатами `ftell()` и комплексных вычислений размеров.
2. **Проверка `pattern`:** добавлена проверка на `NULL` для аргумента `pattern` в режимах регулярных выражений.
3. **Проверка границ файла:** исправлена логика `select_pos + select_size <= file_size`, чтобы не выходить за пределы файла.
4. **Проверки `fseek()`:** добавлены проверки возвращаемого значения, чтобы надёжно определять ошибки при перемещении указателя.
5. **Правильная очистка ресурсов:** в случаях ошибок гарантировано освобождаются все выделенные области памяти.
6. **Обработка ошибок PCRE2:** условие `rc == -1` заменено на `rc < 0`, что корректно обрабатывает любую ошибку PCRE2.
7. **Исправление конфликта имён:** переменная счётчика внутреннего цикла `i` → `j`, чтобы исключить перекрытие с внешним циклом.
8. **Освобождение неиспользуемых ZVAL:** добавлен `zval_dtor()` для всех неиспользуемых PHP-структур сразу после проверки, что они пусты.
9. **Тип `mode`:** изменён с `size_t` на `zend_long`, чтобы соответствовать `zend_parse_parameters`.

---

### Функция `file_select_line`

**Описание проблемы:**
В `file_select_line` обнаружены ошибки, связанные с валидацией входных параметров, неправильным считыванием и обрезкой строки.

**Исправленная версия функции:**

**Основные исправления:**

1. **Типы данных:**

   * Параметры `row` и `mode` — `ssize_t` → `zend_long`.
   * Внутренние переменные (`file_size`, `bytes_read`) — `long` и `size_t`.
2. **Проверка параметров:** добавлена валидация, чтобы `align` был положительным, а `row` — неотрицательным.
3. **Проверка границ при чтении:** условие изменено на `position >= file_size` вместо `position > file_size` — позиция, равная размеру файла, тоже недопустима.
4. **Безопасное чтение:** введено вычисление `remaining_bytes` и `read_size`, чтобы не считывать больше данных, чем есть в файле.
5. **Обработка ошибок чтения:** добавлена проверка `bytes_read < 0`.
6. **Правильный возврат PHP-строки:** вместо `RETURN_STRING()` используется `zend_string_init()` и `RETURN_STR()`, после чего `efree(buffer)`.
7. **Очистка буфера:** `efree(buffer)` выполняется после формирования результирующей строки.
8. **Обработка ошибок выделения памяти:** при неудачном `emalloc()` вызывается `zend_error()`, после чего функция возвращает `FALSE`.

---

### Функция `file_callback_line`

**Описание проблемы:**
Код `file_callback_line` содержал ошибки в инициализации аргументов, управлении памятью и неправильном возврате значений.

**Исправленная версия функции:**

**Основные исправления:**

1. **Типы переменных:**

   * `ssize_t` → `long` для внутреннего счётчика и размеров.
   * `size_t` для работы с буфером.
   * `bool` → `zend_bool` для PHP-специфичных флагов.
2. **Инициализация массива `args`:** все элементы инициализируются как `ZVAL_UNDEF`, что позволяет корректно проверять их состояние перед `efree`.
3. **Проверка выделения памяти:** перед использованием `found_value` добавлена проверка на успешное выделение памяти.
4. **Исправление возврата значения:** вместо `RETURN_STRING(found_value)` используется создание `zend_string` с последующим `efree(found_value)`.
5. **Улучшенная очистка ресурсов:** во всех ветвях выхода (успешного и при ошибках) добавлены проверки `Z_TYPE_P()` и корректное освобождение `zval`s и PCRE2-объектов.
6. **Приведения типов:** явные `(zend_long)` и `(size_t)` там, где это необходимо, чтобы избежать предупреждений компилятора и неопределённого поведения.
7. **Обработка ошибок:** добавлены более подробные сообщения при ошибках и соответствующие коды возврата.

---

### Функция `file_analize`

**Описание проблемы:**
В `file_analize` были найдены ошибки в типах переменных, некорректном подсчёте статистик и неполной обработке граничных случаев (например, файл без завершающего `'\n'`).

**Исправленная версия функции:**

**Основные исправления:**

1. **Типы переменных:**

   * `ssize_t file_size` → `long file_size`
   * `ssize_t bytes_read` → `size_t bytes_read`
   * `ssize_t i` → `size_t i`
   * `ssize_t ini_buffer_size` → `long ini_buffer_size`
   * `ssize_t total_characters` → `long total_characters`
2. **Логика вычисления смещений:** введена переменная `current_offset` для отслеживания текущей позиции в файле; исправлены расчёты `max_length_offset` и `min_length_offset`.
3. **Проверка на пустой файл:** перед чтением последнего символа добавлена проверка `if (file_size > 0)`; результат `ftell()` проверяется на `-1`.
4. **Обработка последней строки без `'\n'`:** добавлена переменная `flow_interruption` и логика, которая учитывает строку, не завершающуюся символом новой строки.
5. **Инициализация `last_symbol`:** `last_symbol` устанавливается в `0`, чтобы корректно работать с подсчётом символов при первой итерации.
6. **Корректный подсчёт `avg_length`:** теперь вычисляется как `(double) total_characters / line_count` с проверкой деления на ноль.
7. **Обработка ошибок памяти:** при неудачном `emalloc()` сразу возвращается `-8`, после чего выполняется `zend_error()` с описанием утечки.
8. **Работа в режиме `mode == 1`:** исправлены расчёты `avg_length`, `min_length` и `max_length` для случая, когда нужно анализировать только первую строку; при отсутствии строк возвращается `line_count = 0`.

---

