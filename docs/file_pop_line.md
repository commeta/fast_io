# Описание функции file_pop_line

Функция file_pop_line предназначена для извлечения и удаления последних строк из файла. Эта функция может быть полезна в ситуациях, когда необходимо работать с файлами в формате стека или журнала, где последняя запись должна быть обработана и затем удалена.


Функция может быть использована для реализации стека LIFO (Last In, First Out) в PHP. В данном документе мы рассмотрим, как использовать эту функцию, принципы работы стека LIFO, сферы его применения, оптимизацию на всех уровнях кэширования и системные преимущества.


Страница описания прокта [Fast_IO Engine](https://github.com/commeta/fast_io).


## Синтаксис

string file_pop_line(string $filename[, int $offset = -1][, int $mode = 0][, int $end = 0])


## Параметры

- **$filename** *(string)*: Путь к файлу, из которого будет извлечена и удалена последняя строка.
- **$offset** *(int, optional)*: Индекс, начиная с которого будет производиться чтение строки. 
- **$mode** (int, optional) - Режим выборки.
- **$end** (int, optional) - Смещение начала выборки в режиме распознавания строк.


Параметр $offset может быть положительным или отрицательным числом:
- если $offset положительное число, то отрезок будет рассчитываться в байтах, с конца файла.
- если $offset отрицательное число, то отрезок будет рассчитываться в строках, с конца файла (-1 последняя, -2 предпоследняя, ...).


Параметр $end работает только при отрицательном $offset, может быть положительным или отрицательным числом:
- если $end положительное число, тогда $end будет количеством байт от конца файла.


Когда параметр $end > 0 больше нуля, file_pop_line отнимает $end от размера файла.
```
$new_file_size = $file_size -= $end;
```
Новый конец файла используется как начало выборки с конца файла:
- возвращает $offset строк от нового конца файла, строки после $new_file_size отбрасываются.
- если смещение $end не указывает на символ переноса строки, то последняя строка будет возвращена не полностью.
- в режиме усечения файла: неполная строка и строки после $new_file_size тоже будут удалены из файла.


#### Режимы выборки

- 0: Усечение файла на размер последней строки, обрезка пробелов справа и символа перевода строки, возврат строки.
- 1: Усечение файла на размер последней строки, возврат сырой строки.
- 2: Обрезка пробелов справа и символа перевода строки, возврат строки.
- 3: Возврат сырой строки.

##### Log mode
- +100 Log mode: Если добавить +100 к любому из вышеперечисленных режимов, функция пересчитает режим mode - 100 но не будет блокировать файл.

Режимы +100 Log mode подходят для работы с файлами журналов. Подробнее: [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).



## Возвращаемые значения

Функция возвращает **строку**, извлеченную из файла, если операция прошла успешно. В случае ошибки при работе с файлом (например, файл не найден, ошибка чтения и т.д.) функция вернет **FALSE** и сгенерирует предупреждение.





## Примеры использования

### Пример 1. Извлечение последней строки из файла
```
$filename = "/path/to/your/file.txt";
$lastLine = file_pop_line($filename);

if ($lastLine !== false) {
    echo "Последняя строка файла: $lastLine";
} else {
    echo "Ошибка при чтении файла";
}
```

### Пример 2. Использование необязательного параметра offset
```
$filename = "/path/to/your/file.txt";
// Предположим, что мы знаем, что строки в файле не превышают 100 байт
$offset = 100;
$lastLine = file_pop_line($filename, $offset);

if ($lastLine !== false) {
    echo "Последняя строка файла: $lastLine";
} else {
    echo "Ошибка при чтении файла";
}
```

Еще [пример](/test/readme.md): Тесты.

## Замечания

- Функция блокирует файл на время своей работы для предотвращения конкурентного доступа.
- Важно учитывать, что функция изменяет файл, удаляя из него указанное количество байт или строк.
- С помощью параметра $offset можно получить любой отрезок файла. Параметр $offset считается с конца файла.



## Принципы стека LIFO

Стек LIFO (Last In, First Out) — это структура данных, в которой последний добавленный элемент извлекается первым. Основные операции со стеком включают:
- **push**: добавление элемента в конец стека.
- **pop**: удаление и извлечение последнего добавленного элемента.

### Пример использования стека LIFO

```
// Добавление строки в файл (имитируем push)
file_insert_line('stack.data', "новая строка");

// Извлечение последней строки из файла (pop)
$lastLine = file_pop_line('stack.data');
echo "Извлеченная строка: " . $lastLine;
```

## Сферы применения стека LIFO
Стек LIFO широко используется в различных областях:
- **Алгоритмы**: рекурсивные алгоритмы, обратный польский нотация (RPN).
- **Парсеры**: синтаксический анализатор выражений.
- **Системы управления памятью**: управление стеком вызовов функций.
- **История браузера**: навигация назад/вперед.

## Оптимизация на всех уровнях кэширования

### Кэширование на уровне ядра Linux
Использование системных вызовов позволяет эффективно работать с файлами, используя кэширование на уровне ядра Linux. Это обеспечивает высокую производительность при работе с файлами.

### Буферизация
Функция использует буферизацию для чтения файла блоками, что уменьшает количество системных вызовов и повышает производительность. Буферизация также помогает минимизировать использование оперативной памяти.

### Оптимизация памяти
Использование динамического выделения памяти позволяет эффективно управлять памятью и избегать излишнего потребления ресурсов.

## Быстродействие функции со стеком LIFO

Функция `file_pop_line` оптимизирована для работы с файлами любого размера. Использование буферизации и эффективное управление памятью позволяет достичь высокой скорости выполнения операций.

## Системные преимущества
- **Низкое потребление памяти**: благодаря динамическому выделению памяти.
- **Высокая производительность**: за счет использования кэширования на уровне ядра и буферизации.
- **Гибкость**: возможность работы с файлами любого размера.
- **Надежность**: обработка ошибок и защита от утечек памяти.




## Стоимость вызова

- CPU Bound - Заполнение буфера и полнотекстовый поиск в начале каждой строки (без выравнивания).
- IO Bound - Чтение файла с конца (без выравнивания чтений больше), усечение файла. 

Низкое потребление, с выравниванием очень низкое, чтение файла с конца, усечение файла.
