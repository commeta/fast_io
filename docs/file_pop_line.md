# Описание функции file_pop_line

Функция file_pop_line предназначена для извлечения и удаления последних строк из файла. Эта функция может быть полезна в ситуациях, когда необходимо работать с файлами в формате стека или журнала, где последняя запись должна быть обработана и затем удалена.


Функция может быть использована для реализации стека LIFO (Last In, First Out) в PHP. В данном документе мы рассмотрим, как использовать эту функцию, принципы работы стека LIFO, сферы его применения, оптимизацию на всех уровнях кэширования и системные преимущества.


Страница описания прокта [Fast_IO Engine](https://github.com/commeta/fast_io).


## Синтаксис

string file_pop_line(string $filename[, int $offset = -1][, int $mode = 0][, int $end = 0])


## Параметры

- **$filename** *(string)*: Путь к файлу, из которого будет извлечена и удалена последняя строка.
- **$offset** *(int, optional)*: Индекс, начиная с которого будет производиться чтение строки. 
- **$mode** (int, optional) - Режим выборки.
- **$end** (int, optional) - Смещение начала выборки в режиме распознавания строк.


Параметр $offset может быть положительным или отрицательным числом:
- если $offset положительное число, то отрезок будет рассчитываться в байтах, с конца файла.
- если $offset отрицательное число, то отрезок будет рассчитываться в строках, с конца файла (-1 последняя, -2 предпоследняя, ...).


Параметр $end работает только при отрицательном $offset, может быть положительным или отрицательным числом:
- если $end положительное число, тогда $end будет количеством байт от конца файла.


Когда параметр $end > 0 больше нуля, file_pop_line отнимает $end от размера файла.
```
$new_file_size = $file_size -= $end;
```
Новый конец файла используется как начало выборки с конца файла:
- возвращает $offset строк от нового конца файла, строки после $new_file_size отбрасываются.
- если смещение $end не указывает на символ переноса строки, то последняя строка будет возвращена не полностью.
- в режиме усечения файла: неполная строка и строки после $new_file_size тоже будут удалены из файла.


#### Режимы выборки

- 0: Усечение файла на размер последней строки, обрезка пробелов справа и символа перевода строки, возврат строки.
- 1: Усечение файла на размер последней строки, возврат сырой строки.
- 2: Обрезка пробелов справа и символа перевода строки, возврат строки.
- 3: Возврат сырой строки.

##### Log mode
- +100 Log mode: Если добавить +100 к любому из вышеперечисленных режимов, функция пересчитает режим mode - 100 но не будет блокировать файл.

Режимы +100 Log mode подходят для работы с файлами журналов. Подробнее: [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).



## Возвращаемые значения

Функция возвращает **строку**, извлеченную из файла, если операция прошла успешно. В случае ошибки при работе с файлом (например, файл не найден, ошибка чтения и т.д.) функция вернет **FALSE** и сгенерирует предупреждение.





## Примеры использования

### Пример 1. Извлечение последней строки из файла
```
$filename = "/path/to/your/file.txt";
$lastLine = file_pop_line($filename);

if ($lastLine !== false) {
    echo "Последняя строка файла: $lastLine";
} else {
    echo "Ошибка при чтении файла";
}
```

### Пример 2. Использование необязательного параметра offset
```
$filename = "/path/to/your/file.txt";
// Предположим, что мы знаем, что строки в файле не превышают 100 байт
$offset = 100;
$lastLine = file_pop_line($filename, $offset);

if ($lastLine !== false) {
    echo "Последняя строка файла: $lastLine";
} else {
    echo "Ошибка при чтении файла";
}
```

Еще [пример](/test/readme.md): Тесты.

## Замечания

- Функция блокирует файл на время своей работы для предотвращения конкурентного доступа.
- Важно учитывать, что функция изменяет файл, удаляя из него указанное количество байт или строк.
- С помощью параметра $offset можно получить любой отрезок файла. Параметр $offset считается с конца файла.



## Принципы стека LIFO

Стек LIFO (Last In, First Out) — это структура данных, в которой последний добавленный элемент извлекается первым. Основные операции со стеком включают:
- **push**: добавление элемента в конец стека.
- **pop**: удаление и извлечение последнего добавленного элемента.

### Пример использования стека LIFO

```
// Добавление строки в файл (имитируем push)
file_insert_line('stack.data', "новая строка");

// Извлечение последней строки из файла (pop)
$lastLine = file_pop_line('stack.data');
echo "Извлеченная строка: " . $lastLine;
```

## Сферы применения стека LIFO
Стек LIFO широко используется в различных областях:
- **Алгоритмы**: рекурсивные алгоритмы, обратный польский нотация (RPN).
- **Парсеры**: синтаксический анализатор выражений.
- **Системы управления памятью**: управление стеком вызовов функций.
- **История браузера**: навигация назад/вперед.


### Межпроцессное взаимодействие (IPC)

Для межпроцессного взаимодействия (IPC) можно использовать файл как общий ресурс, к которому имеют доступ несколько процессов. Каждый процесс может добавлять строки в файл (push) или извлекать строки из файла (pop).



Межпроцессное взаимодействие (IPC) в контексте PHP и файловой системы представляет собой метод обмена данными между процессами, выполняющимися на одной или нескольких машинах. В PHP, несмотря на отсутствие встроенных механизмов IPC, можно использовать различные подходы для реализации взаимодействия между процессами. Один из таких подходов — использование файловой системы как посредника для передачи данных.

### Основные концепции IPC в PHP

1. **Файловая система как общий ресурс**: Файлы могут служить общим ресурсом для нескольких процессов. Процессы могут читать и записывать данные в файлы, что позволяет им обмениваться информацией.

2. **Синхронизация доступа**: Для предотвращения гонок данных и обеспечения целостности данных требуется синхронизация доступа к файлам. Это может быть достигнуто с помощью блокировок файлов (file locking).

3. **Буферизация и кэширование**: Важно учитывать уровни кэширования и буферизации, предоставляемые операционной системой, чтобы обеспечить корректное и эффективное взаимодействие между процессами.

### Уровни кэширования ядра Linux

1. **Буферизация ввода-вывода (I/O buffering)**: Linux использует буферизацию для уменьшения количества прямых операций ввода-вывода. Данные сначала записываются в буферы в памяти, а затем асинхронно записываются на диск.

2. **Кэширование страниц (Page Cache)**: Это механизм, при котором содержимое файлов кэшируется в оперативной памяти для ускорения доступа. При чтении файла данные сначала ищутся в кэше страниц, что позволяет избежать медленных операций чтения с диска.

3. **Журналирование файловой системы (Filesystem Journaling)**: Некоторые файловые системы, такие как ext4, используют журналирование для обеспечения целостности данных. Журналирование помогает восстановить состояние файловой системы после сбоев.

### Реализация стека LIFO и функции file_pop_line

Для реализации стека LIFO с использованием файловой системы можно использовать файл как контейнер для данных стека. Функция file_pop_line позволяет извлекать последнюю строку из файла и удалять её, что соответствует операции pop в стеке LIFO.

#### Технологические аспекты:

1. **Запись данных (Push)**:
   - Процесс добавляет строку в конец файла.
   - Используется функция file_insert_line, с автоматическим добавлением символа перевода строки.
   - Используется блокировка файла (flock) для предотвращения гонок данных.

2. **Извлечение данных (Pop)**:
   - Функция file_pop_line открывает файл и читает его содержимое.
   - Последняя строка извлекается и удаляется из файла.
   - Для эффективности может использоваться буферизация чтения.
   - После извлечения строки файл усекается на размер последней строки.
   - Блокировка файла также может быть использована для предотвращения одновременного доступа.

3. **Синхронизация и атомарность**:
   - Блокировка файла (flock) обеспечивает атомарность операций записи и чтения.
   - Важно правильно обрабатывать ошибки блокировки и повторять попытки при необходимости.

4. **Кэширование и буферизация**:
   - При записи данных в файл операционная система использует буферы для временного хранения данных перед их записью на диск.
   - Чтение данных сначала происходит из кэша страниц, что ускоряет доступ.


### Преимущества и недостатки подхода

**Преимущества:**
- Простота реализации: Использование файловой системы не требует дополнительных библиотек или расширений.
- Портативность: Решение работает на всех UNIX подобных системах, поддерживающих PHP и файловую систему.

**Недостатки:**
- Производительность: Операции ввода-вывода на диске могут быть медленными по сравнению с другими методами IPC (например, сокетами или разделяемой памятью).
- Сложности синхронизации: Требуется тщательная обработка блокировок для предотвращения гонок данных.




## Оптимизация на всех уровнях кэширования

### Кэширование на уровне ядра Linux
Использование системных вызовов позволяет эффективно работать с файлами, используя кэширование на уровне ядра Linux. Это обеспечивает высокую производительность при работе с файлами.

### Буферизация
Функция использует буферизацию для чтения файла блоками, что уменьшает количество системных вызовов и повышает производительность. Буферизация также помогает минимизировать использование оперативной памяти.

### Оптимизация памяти
Использование динамического выделения памяти позволяет эффективно управлять памятью и избегать излишнего потребления ресурсов.

## Быстродействие функции со стеком LIFO

Функция `file_pop_line` оптимизирована для работы с файлами любого размера. Использование буферизации и эффективное управление памятью позволяет достичь высокой скорости выполнения операций.

## Системные преимущества
- **Низкое потребление памяти**: благодаря динамическому выделению памяти.
- **Высокая производительность**: за счет использования кэширования на уровне ядра и буферизации.
- **Гибкость**: возможность работы с файлами любого размера.
- **Надежность**: обработка ошибок и защита от утечек памяти.




## Стоимость вызова

- CPU Bound - Заполнение буфера и полнотекстовый поиск в начале каждой строки (без выравнивания).
- IO Bound - Чтение файла с конца (без выравнивания чтений больше), усечение файла. 

Низкое потребление, с выравниванием очень низкое, чтение файла с конца, усечение файла.
