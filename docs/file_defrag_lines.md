# Описание функции file_defrag_lines

Функция file_defrag_lines написана на языке C и предназначена для использования в PHP через специализированное расширение Fast_IO. 

Функция file_defrag_lines удаляет строки из файла данных для дефрагментации. 
Во время удаления устанавливается портируемая блокировка на файл, чтобы другие экземпляры ожидали освобождения файла. 
Данные копируются порциями во временный файл с последующим переименованием, что позволяет избежать загрузки всего файла в память.


Страница описания прокта [Fast_IO Engine](https://github.com/commeta/fast_io).


## Синтаксис

int file_defrag_lines(string $filename, string $line_key[, int mode])


### Параметры

- **$filename** *(string)*: Путь к файлу, из которого будут удалены пары ключ-значение.
- **$line_key** *(string)*: Ключ, по которому будут идентифицированы и удалены пары ключ-значение. Если не указан, функция удалит все записи, начинающиеся с специального символа (ASCII Code 127).
- **$mode** (int, optional) - Режим дефрагментации.

### Возвращаемые значения

- Возвращает количество удаленных строк.
- Возвращает отрицательное число (int), представляющее код ошибки, в случае возникновения ошибок при выполнении операций с файлом.

## Ошибки

Функция может возвращать следующие коды ошибок:

- -1: Не удалось открыть исходный файл.
- -2: Не удалось создать временный файл.
- -3: Не удалось заблокировать файл.
- -4: Не удалось записать данные в временный файл.
- -5: Не удалось изменить размер файла.
- -8: Произошла ошибка выделения памяти.

## Пример использования

Для использования этой функции необходимо, чтобы ваше PHP-окружение поддерживало соответствующее расширение.
```
<?php
$filename = "/path/to/your/file.txt";
$line_key = "yourKey"; // или спецсимвол chr(127)

$result = file_defrag_lines($filename, $line_key);

if ($result > 0) {
    echo "Ключ успешно удален.\n";
} else {
    echo "Произошла ошибка: код {$result}.\n";
}
?>
```

Еще [пример](/test/readme.md): Тесты.


### Особенности работы

Функция работает с текстовыми файлами, где каждая строка представляет собой пару ключ-значение, разделенные пробелом. При удалении функция создает временный файл, в который копируются все строки, не соответствующие указанному ключу. После завершения чтения и копирования, временный файл заменяет оригинальный, тем самым удаляя указанную пару ключ-значение.

- В режиме mode = 0 данные из временного файла копируются обратно в файл данных, для работы в цепочке.
- В режиме mode = 1 временный файл будет переименован без обратного копирования. Если параллельная копия Fast_IO функции ожидает снятия блокировки файла, то она завершится с ошибкой блокировки.
- +100 Log mode: Если добавить +100 к любому из вышеперечисленных режимов, функция пересчитает режим mode -= 100 но не будет блокировать файл.

Режимы +100 Log mode подходят для работы с файлами журналов.

Фрагментация в файле данных возникает после операции скрытия строк: file_erase_line, file_update_line или file_replace_line с установкой спецсимвола (ASCII Code 127).
Если строка начинается с спецсимвола (ASCII Code 127) она будет удалена из файла.


### Ограничения

- Файл должен быть доступен для чтения и записи.


## Примечания

- Функция работает путем создания временного файла, в который копируются все строки из исходного файла, не соответствующие заданному ключу. После завершения операции данные копируются обратно, либо исходный файл заменяется временным.
- Важно обеспечить достаточные права доступа к файлам и директориям для корректной работы функции.
- Рекомендуется делать резервную копию файла перед использованием этой функции для предотвращения потери данных.

## Стоимость вызова

- CPU Bound - Заполнение буфера и полнотекстовый поиск в каждой строке.
- IO Bound - Посекторное чтение файла в буфер, запись строк во временный файл.

Сверх высокое потребление, чтение\запись всего файла.

## Заключение

Функция file_defrag_lines предоставляет эффективный способ удаления данных из текстовых файлов в PHP приложениях. Благодаря использованию временного файла и порционного чтения, функция обеспечивает высокую производительность и минимизацию использования памяти даже для больших файлов данных.
