# Описание функции file_insert_line

Функция file_insert_line предназначена для добавления строк с определённым выравниванием в файл. Это может быть полезно для создания структурированных текстовых баз данных или лог-файлов, где каждая запись должна начинаться с новой строки и иметь фиксированную длину. Функция реализована на языке C и доступна в PHP через специальное расширение.


Страница описания прокта [Fast_IO Engine](https://github.com/commeta/fast_io).


## Синтаксис

int file_insert_line(string $filename, string $line[, int $mode = 0][, int $line_length = strlen($line)])


## Параметры

Функция принимает три аргумента:

- $filename (string): Путь к файлу, в который будет производиться запись.
- $line (string): Строка, которую необходимо записать в файл.
- $mode (int, optional) - Режим.
- $line_length (int, optional): Число, размер кадра в файле.


#### Режимы
- 0, 2: Режим с добавлением символа перевода строки.
- 1, 3: Режим без добавления символа перевода строки.

##### Log mode
- +100 Log mode: Если добавить +100 к любому из вышеперечисленных режимов, функция пересчитает режим mode - 100 но не будет блокировать файл.

Режимы +100 Log mode подходят для работы с файлами журналов. Подробнее: [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).


## Возвращаемые значения

В режиме mode 2, 3 возвращает смещение начала строки в файле данных, если запись прошла успешно. 
Режимы mode 0, 1 возвращает file_size / line_length номер строки в файле с выравниванием.
В случае возникновения ошибки возвращается отрицательное число, указывающее на тип ошибки:

- -1: Не удалось открыть файл.
- -2: Не удалось заблокировать файл для записи.
- -3: Ошибка записи в файл.
- -8: Ошибка выделения памяти.


## Особенности работы

При подготовке строки line к записи в файл, создается временный буфер размером line_length байт, заполненный пробелами. 
Если строка len меньше или равна line_length, то строка копируется в начало буфера. Если строка len больше line_length, то строка копируется в буфер насколько поместится.
В режимах mode = 1 в конце буфера устанавливается символ перевода строки.


## Пример использования
```
<?php
for($id=0; $id <=500; $id++){
	print_r(
		file_insert_line(__DIR__ . '/fast_io1.dat', 'index_' . $id . ' file_insert_line_' . $id . ' ' . str_pad('', 92, '1234567890'), 0, 8192) . ', '
	);
}
```

Еще [пример](/test/readme.md): Тесты.

В этом примере мы пытаемся добавить строку "index_[id] file_insert_line_[id] [auto_fill]" в файл fast_io1.dat, при этом каждая запись должна занимать ровно 8192 символов. Если операция проходит успешно, функция вернёт номер строки, в которую была добавлена запись. В случае ошибки будет возвращён соответствующий код.

### Формат файла

Файл будет содержать данные в формате ключ-значение, разделённые пробелом, каждая пара на новой строке. Например:

```
index_0 data_insert_key_value_0
index_1 data_insert_key_value_1
index_2 data_insert_key_value_2
```


## Примечания

- Файл автоматически блокируется на время записи для предотвращения одновременного доступа.
- Если файл не существует, он будет создан.
- Длина line может быть меньше line_align. В этом случае оставшаяся часть строки будет заполнена пробелами. Если $line длиннее $line_length, строка будет обрезана до нужной длины.


## Стоимость вызова

- CPU Bound - Подготовка строки к записи с учетом выравнивания.
- IO Bound - Запись строки в конец файла.

Очень низкое потребление, запись строки в конец файла.
