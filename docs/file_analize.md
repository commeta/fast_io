# Описание функции file_analize

Функция file_analize написана на языке C и предназначена для использования в PHP через специализированное расширение Fast_IO. 
Функция анализирует текстовый файл и определяет длины строк в этом файле. 

Функция открывает указанный текстовый файл, последовательно читает его содержимое и вычисляет длину каждой строки. 
В результате работы функция возвращает массив данных анализа файла.


Страница описания прокта [Fast_IO Engine](https://github.com/commeta/fast_io).


### Синтаксис

array file_analize(string $filename [, int mode = 0])


#### Параметры

- **filename**: Путь к текстовому файлу, который необходимо проанализировать.
- **mode** (int, optional): Режим анализа.

#### Режимы
- В режиме 0 - массив значений анализа строк по всему файлу.
- В режиме 1 - массив значений анализа строк по первой строке.

##### Log mode
- +100 Log mode: Если добавить +100 к любому из вышеперечисленных режимов, функция пересчитает режим mode - 100 но не будет блокировать файл.

Режимы +100 Log mode подходят для работы с файлами журналов. Подробнее: [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).

### Ошибки
- Возвращает -1, если не удалось открыть файл.
- Возвращает -2, если не удалось заблокировать файл.
- Возвращает -8, если произошла ошибка выделения памяти.

### Элементы массива
- min_length - Минимальная длина строки.
- max_length - Максимальная длина строки.
- avg_length - Средняя длина строки.
- line_count - Количество прочитанных строк.
- total_characters - Всего символов.
- flow_interruption - 1 если произошла ошибка прерванной записи в файле, когда в конце файла нет перевода строки.
		    
При наличии прерванной записи в файле, следующая запись будет объединена с предыдущей если не выполнить дефрагментацию.

Во время выполнения Fast_IO функций все операции поиска производятся в найденных строках, без символа перевода строки парсер не приступит к поиску подстрок.
Такие строки всегда игнорируются.

В последнем секторе можно сохранять данные порциями, но в рамках одной транзакции.

### Поведение Fast_IO функции при аварийном завершении транзакции
- file_push_data, file_push_line, file_insert_line - всегда отменяют последнюю запись и выходят с ошибкой.
- file_replace_line, file_defrag_data, file_defrag_line - в случае ошибки записи при обратном копировании, делает переименование временных файлов и данные остаются целы. Если параллельная копия Fast_IO функции ожидает снятия блокировки файла, то она завершится с ошибкой блокировки.
- file_erase_line - проверяет количество записанных байт, в случае ошибки записи файла (-3) эту операцию не отменить!
- file_update_line, file_update_array - проверяет количество записанных байт, в случае ошибки записи файла (-4) эту операцию не отменить!

Ошибка при записи в функции file_update_line может возникнуть при обновлении последних секторов файла если закончилось место на диске, а длина строки выходит за пределы файла.

Ошибка записи в функции file_erase_line может говорить только об отказе оборудования.

#### Пример #1 Базовое использование file_analize
```
<?php
for($i=0; $i <=500; $i++){
	print_r(
		file_insert_line(__DIR__ . '/fast_io1.dat', 'index_' . $i . ' file_insert_line_' . $i . ' ' . str_pad('', 92, '1234567890'), 8192) . ', '
	);
}

print_r([
	file_analize(__DIR__ . '/fast_io1.dat'),
	file_analize(__DIR__ . '/fast_io1.dat', 1),
]);

```

```
(
    [0] => Array
        (
            [0] => Array
                (
                    [min_length] => 8192
                    [max_length] => 8192
                    [avg_length] => 8192
                    [line_count] => 501
                    [total_characters] => 4104192
                    [flow_interruption] => 0
                )
        )

    [1] => Array
        (
            [0] => Array
                (
                    [min_length] => 8192
                    [max_length] => 8192
                    [avg_length] => 8192
                    [line_count] => 1
                    [total_characters] => 8192
                    [flow_interruption] => 0
                )
        )

)

```


### Примечания

- Если последняя строка файла не заканчивается символом перевода строки, её длина всё равно корректно учитывается.
- Функция использует эксклюзивную блокировку файла во время обработки, чтобы предотвратить одновременные изменения.


## Стоимость вызова

- CPU Bound - Заполнение буфера и полнотекстовый поиск каждой строки.
- IO Bound - Посекторное чтение файла в буфер.

Среднее потребление, чтение всего файла.

