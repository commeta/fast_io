# Fast_IO - Расширение для PHP 8 (BETA)

## Описание

Fast_IO - это высокопроизводительное расширение для PHP 8, разработанное для эффективной работы с файлами данных. Оно предлагает набор функций для чтения, записи, обновления и удаления пар ключ-значение в файлах данных, используя низкоуровневый посекторный доступ и механизмы блокировки для синхронизации доступа. Это расширение идеально подходит для работы с большими объемами данных, обеспечивая высокую скорость и эффективность операций благодаря оптимизированному управлению памятью и дисковым вводом-выводом.

## Основные возможности

- **Быстрая запись и чтение**: Позволяет выполнять операции записи и чтения для строк с высокой производительностью.
- **Транзакции с блокировкой**: Использует механизм портируемой блокировки файла для обеспечения синхронизации доступа между параллельными операциями.
- **Эффективное управление памятью**: Чтение данных осуществляется порциями, что предотвращает переполнение памяти при работе с большими файлами.
- **Поддержка индексных файлов**: Улучшает производительность поиска по ключу за счет использования отдельных индексных файлов.
- **Бинарная безопасность**: Функции с постфиксом data обеспечивают безопасную работу с бинарными данными.

## Функции расширения
- [file_callback_line](/docs/file_callback_line.md) - Построчное чтение файла с функцией обратного вызова.
- [file_insert_line](/docs/file_insert_line.md) - Вставка строк с выравниванием в файл.
- [file_pop_line](/docs/file_pop_line.md) - Извлечение и удаление последней строки из файла.
- [file_defrag_data](/docs/file_defrag_data.md) - Дефрагментация файла данных и соответствующего индексного файла.
- [file_push_data](/docs/file_push_data.md) - Добавление порции бинарных данных файл данных и соответствующий индексный файл.
- [file_search_data](/docs/file_search_data.md) - Поиск порции бинарных данных по ключу, с использованием индексного файла.
- [file_erase_line](/docs/file_erase_line.md) - Стереть строку файле данных.
- [file_search_line](/docs/file_search_line.md) - Поиск строки по ключу в файле данных, возвращает строку.
- [file_search_array](/docs/file_search_array.md) - Поиск строк по ключу в файле данных, возвращает массив.
- [file_defrag_lines](/docs/file_defrag_lines.md) - Удаление строк из файла данных.
- [file_get_keys](/docs/file_get_keys.md) - Извлечение уникальных ключей из текстового файла.
- [file_replace_line](/docs/file_replace_line.md) - Замена строки по ключу.
- [file_select_line](/docs/file_select_line.md) - Выборка строки из файла, по указанному номеру или смещению.
- [file_select_array](/docs/file_select_array.md) - Массовая выборка строк из файла, по указанному смещению и размеру.
- [file_update_line](/docs/file_update_line.md) - Обновление строки в файле, по указанному смещению и размеру.
- [file_update_array](/docs/file_update_array.md) - Массовое обновление строк в файле.
- [file_analize](/docs/file_analize.md) - Возвращает статистику для анализа данных и диагностики файла.
- [replicate_file](/docs/replicate_file.md) - Репликация файла данных.


## Особенности реализации

- Все функции используют UNIX портируемую блокировку файла на запись, что гарантирует целостность данных при параллельном доступе [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).
- Расширение разработано без использования сторонних фреймворков и библиотек, обеспечивая высокую производительность и совместимость с PHP 8.
- Функции производят чтение данных порциями, оптимизируя использование памяти и уменьшая нагрузку на систему.
- Стоимость вызовов функций с низким потреблением в случае попадания в кэш, сопоставима со скоростью доступа к кэш памяти.

Fast_IO представляет собой мощное расширение для PHP 8, которое значительно упрощает и ускоряет работу с большими объемами данных. Благодаря эффективным механизмам чтения, записи, блокировки и управления памятью, разработчики могут создавать высокопроизводительные приложения, оптимизированные для обработки файлов данных.

### Структура файла
Строка line делится на подстроки: line_key, line_value.

Ключом line_key может быть любой печатный символ, зарезервированные символы: 
- ASCII Code 32 space (пробел) - разделитель подстрок.
- ASCII Code 127 delete (не печатный) - метка пустого кадра, ставится в начале строки заполненной пробелами.
- ASCII Code 10 line feed (перевод строки) - разделитель строк.
- ASCII Code 0 null character (нулевой символ) - разделитель подстрок.

Функции: file_defrag_data, file_defrag_lines, file_erase_line, file_get_keys, file_push_data, file_replace_line, file_search_data - при индексации строк проводят анализ первой подстроки, рассматривая любой печатный символ как ключ строки. Ключ всегда должен заканчиваться пробелом.

### Поведение Fast_IO функции при аварийном завершении транзакции
- file_push_data, file_insert_line - всегда отменяют последнюю запись и выходят с ошибкой.
- file_replace_line, file_defrag_data, file_defrag_line - в случае ошибки записи при обратном копировании, делает переименование временных файлов и данные остаются целы. Если параллельная копия Fast_IO функции ожидает снятия блокировки файла, то она завершится с ошибкой блокировки.
- file_erase_line - проверяет количество записанных байт, в случае ошибки записи файла (-3) эту операцию не отменить!
- file_update_line, file_update_array - проверяет количество записанных байт, в случае ошибки записи файла (-4) эту операцию не отменить!

Ошибка при записи в функциях file_update_line, file_update_array может возникнуть при обновлении последних секторов файла если закончилось место на диске, а длина строки выходит за пределы файла.

Ошибка записи в функции file_erase_line может говорить только об отказе оборудования.


### Регулярные выражения PCRE2

Версия на момент разработки PCRE2 10.42

В Fast_IO Engine реализована функция find_matches_pcre2, во всех функциях чтения файла подсистема PCRE2 инициализируется однократно при массовых операциях, это позволяет сэкономить системные ресурсы на инициализацию и компиляцию паттернов.

- [Краткий обзор лучших и быстрых типов регулярных выражений в PHP8](/docs/find_matches_pcre2.md)
- [Perl-compatible Regular Expressions (revised API: PCRE2)](https://pcre2project.github.io/pcre2/doc/html/index.html)



## Примеры использования

Для каждой функции расширения Fast_IO предоставлены подробные описания с примерами на PHP. Эти примеры помогут разработчикам быстро начать работу с расширением и эффективно использовать его возможности в своих проектах.

## Параметры

buffer_size - это параметр конфигурации, определяющий размер буфера для операций чтения\записи. Указание оптимального размера буфера может значительно улучшить производительность при работе с большими объемами данных.

#### Установка через php.ini

Для настройки размера буфера в глобальной конфигурации PHP добавьте или измените следующую строку в файле php.ini:

fast_io.buffer_size = 4096 // От 16 байт

Значение указывается в байтах. По умолчанию размер буфера установлен равным 4096 байт (4 КБ).

#### Использование в коде PHP

Вы можете получить текущее значение buffer_size или установить новое значение в начале вашего PHP скрипта:
```
// Получить текущий размер буфера
$currentBufferSize = ini_get('fast_io.buffer_size');

// Установить новый размер буфера, до вызова функций!
ini_set('fast_io.buffer_size', 8192); // 8 КБ
```

#### Инициализация

Инициализация параметров в PHP происходит во время запуска сервера или выполнения скрипта. В приведенном примере кода инициализация параметра "fast_io.buffer_size" осуществляется при инициализации модуля fast_io в PHP.

### Примечания
- Изменение размера буфера во время выполнения скрипта может повлиять на производительность операций ввода-вывода, выполняемых после этого изменения.
- Выбор оптимального размера буфера зависит от конкретных задач и условий работы приложения. Рекомендуется проводить тестирование с различными значениями, чтобы найти наилучший вариант.
- Указывайте размер буфера ориентируясь на размер порции данных, значения по умолчанию 4096 достаточно для работы со строками размером 4096 байт.
- При большом размере буфера возможны лишние чтения файла, например при полнотекстовом поиске, когда значение может быть найдено в начале файла, а он будет прочитан на величину буфера.
- При очень низком размере буфера, количество запросов на чтение\запись может существенно вырасти, что создаст дополнительную нагрузку. 
- В операциях поиска строк создается динамический буфер dynamic_buffer по принципу dynamic_buffer_size += buffer_size. Размер динамического буфера будет установлен на величину максимального всплеска размера строки.
- Если размер файла меньше buffer_size, то buffer_size уменьшается до размера файла.

dynamic_buffer используется для хранения частей файла, считываемых в память для поиска определенного ключа или выполнения сопоставления с регулярным выражением. Работа dynamic_buffer основана на следующих принципах:

### Как Работает dynamic_buffer

1. **Инициализация и Размер**: Буфер инициализируется с начальным размером, определенным значением fast_io.buffer_size.

2. **Чтение из Файла**: Данные считываются из файла блоками размером fast_io.buffer_size и добавляются в dynamic_buffer. В режиме поиска строк, если строка не помещается в текущий размер буфера, dynamic_buffer увеличивается на размер fast_io.buffer_size на каждой итерации чтения из файла.

3. **Увеличение Размера**: Размер dynamic_buffer увеличивается на ini_buffer_size. Увеличение происходит с помощью функции erealloc, которая пытается изменить размер уже выделенной памяти, сохраняя при этом существующие данные.


### Использование системного буфера C

Когда вы работаете с файловыми операциями, такими как чтение из файла с помощью буферных функции, используется системный буфер. Этот буфер служит промежуточным хранилищем данных между физическим файлом на диске и оперативной памятью компьютера. Системный буфер позволяет оптимизировать ввод-вывод за счет минимизации количества обращений к диску, что значительно увеличивает производительность операций чтения и записи.

В процессе работы системный буфер используется для временного хранения данных, считанных из файла, перед тем как они будут помещены в пользовательский буфер (dynamic_buffer). Это позволяет эффективно читать данные большими блоками, что уменьшает количество обращений к диску.

Системные функции чтения и записи используют внутренний буфер для оптимизации операций ввода-вывода. Даже если вы запрашиваете чтение или запись всего одного байта, эти функции обычно считывают или записывают данные блоками.

Когда вы запрашиваете чтение 1 байта, системная функция может считать из файла целый блок данных и сохранить его во внутреннем буфере. При последующих вызовах чтение данных будет возвращаться из этого буфера, что уменьшает количество обращений к ядру операционной системы и ускоряет процесс чтения.

Аналогично, при запросе записи 1 байта, данные сначала помещаются во внутренний буфер. Когда буфер заполняется или когда файл закрывается, данные из буфера записываются в файл.

Размер блока (blocksize) зависит от системы и может быть различным. Во многих системах размер блока составляет 4096 байт (4 КБ) или 8192 байта (8 КБ), но это не жёстко заданное значение и может отличаться в зависимости от файловой системы и конкретной операционной системы.


### Преимущества использования системного буфера C

1. **Эффективность**: Чтение данных большими блоками и их временное хранение в системном буфере уменьшает нагрузку на дисковую систему и повышает общую производительность операций ввода-вывода.

2. **Уменьшение Задержек**: Минимизация обращений к диску снижает задержки, связанные с механическими особенностями работы жестких дисков и особенностями работы солид-стейт дисков (SSD).


### Использование системного кэша ядра Linux

Когда функция запрашивает данные из файла, системный кэш ядра Linux играет ключевую роль в оптимизации производительности при обращении к данным на диске.

### Как работает системный кэш ядра Linux:

1. **Чтение данных**: Когда функция пытается прочитать данные из файла, операционная система сначала проверяет, находятся ли эти данные в системном кэше (кэше страниц ядра). Если данные уже есть в кэше, они могут быть немедленно предоставлены процессу без необходимости обращения к физическому диску.

2. **Кэширование данных**: Если запрашиваемые данные отсутствуют в кэше, ядро загружает эти данные с диска в системный кэш перед их предоставлением процессу. При этом, данные загружаются блоками, что повышает эффективность последующих обращений к этим же данным.

3. **Запись данных**: При записи данных в файл, данные сначала помещаются в системный кэш, и только потом, в зависимости от политики кэширования и активности системы, они могут быть записаны на физический носитель. Это позволяет уменьшить количество операций записи на диск, что положительно сказывается на сроке службы диска и производительности системы.

### Преимущества использования системного кэша:

- **Уменьшение задержек**: Доступ к данным из кэша значительно быстрее доступа к данным с физического диска, что уменьшает время выполнения операций чтения/записи.
- **Оптимизация работы с диском**: Кэширование позволяет сократить количество обращений к диску за счет предварительного чтения и отложенной записи, что повышает общую производительность системы.
- **Повышение пропускной способности**: Системный кэш позволяет обрабатывать больше операций ввода-вывода за единицу времени благодаря уменьшению количества фактических обращений к диску.

Использование системного кэша ядра Linux помогает ускорить процесс поиска значений в файле, особенно если файл часто используется или его размер превышает размер оперативной памяти. Это делает чтение данных более эффективным и уменьшает общее время выполнения функции.


### Упреждающее чтение (Read-Ahead)

Упреждающее чтение — это метод, используемый операционными системами и файловыми системами, для увеличения производительности чтения данных с диска. ОС заранее читает с диска больше данных, чем было запрошено приложением, предполагая, что эти данные скоро понадобятся. Это уменьшает количество обращений к диску и увеличивает скорость чтения данных.

При чтении данных упреждающее чтение может быть неявно использовано через механизмы ОС и файловой системы, когда вы выполняете запрос для чтения блоков данных из файла. ОС может заранее загружать данные в системный буфер, ускоряя доступ к последующим блокам данных.

### Оптимизация записи на диск

**Задержанная запись (Write-Back Caching)**: При записи данных они сначала помещаются в буфер (кэш) в памяти, а не сразу записываются на диск. Запись на физический носитель происходит позже, в более удобное время. Это уменьшает количество операций записи на диск, что положительно сказывается на производительности и сроке службы диска.


---

## Установка

### Шаг 1: Создание каркаса расширения
Скопируйте файлы: `config.m4`, `fast_io.c`, `fast_io.h` в текущий каталог проекта.

Для начала, вам нужно создать каркас вашего расширения. Это можно сделать вручную или с помощью инструмента ext_skel в исходниках PHP. Например:
```
phpize
./configure
make
make test
```

Это создаст базовую структуру для вашего расширения.



### Шаг 2: Компиляция и тестирование

Вам нужно скомпилировать расширение и протестировать его. Используйте: phpize, ./configure, make и make test для компиляции и установки вашего расширения.

После установки не забудьте добавить строку `extension=fast_io.so` в ваш `php.ini`, чтобы активировать расширение.

Теперь вы можете вызывать новые функции из PHP как обычные функции.

Результат тестирования: Ubuntu 24.04, Ryzen 12 Cores, 16GB RAM, SATA 3 SSD.


**test/test.php**
```
file_insert_line: 0.10697793960571 (0.00001070)
file_search_line: 2.9135210514069 (0.00029135)
file_search_line repeat: 0.084739208221436 (0.00000847)
file_defrag_lines: 0.65570092201233 (0.00006557)
file_push_data: 0.21720695495605 (0.00002172)
file_search_data: 2.353935956955 (0.00023539)
file_search_data repeat: 0.15796780586243 (0.00001580)
file_pop_line: 0.24059700965881 (0.00002406)
```

Функция запускалась в цикле 10000 раз, с линейным инкрементом индекса (без попадания в кэш) и repeat многократный поиск одного и того же индекса.
Показано время в секундах по результатам теста: 10000 запусков (1 запуск).


**test/auto_test.php**
```
Check file_insert_line: time: 2.5057950019836 - PASS
rchar: 752348375 (300.24 millions per sec)
wchar: 201599266 (80.45 millions per sec)
syscr: 88584 (35,351.65 per sec)
syscw: 11219 (4,477.22 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 201805824 (80.54 millions per sec)
cancelled_write_bytes: 200536064 (80.03 millions per sec)

Check file_analize: time: 3.9903860092163 - PASS
rchar: 5995335071 (1,502.44 millions per sec)
wchar: 179673526 (45.03 millions per sec)
syscr: 737563 (184,835.00 per sec)
syscw: 10526 (2,637.84 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 179884032 (45.08 millions per sec)
cancelled_write_bytes: 178995200 (44.86 millions per sec)

Check file_get_keys: time: 2.1031000614166 - PASS
rchar: 1171380936 (556.98 millions per sec)
wchar: 195020046 (92.73 millions per sec)
syscr: 98643 (46,903.62 per sec)
syscw: 10670 (5,073.46 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 195219456 (92.82 millions per sec)
cancelled_write_bytes: 188624896 (89.69 millions per sec)

Check file_search_array: time: 2.5878760814667 - PASS
rchar: 2026237164 (782.97 millions per sec)
wchar: 168664934 (65.18 millions per sec)
syscr: 225525 (87,146.75 per sec)
syscw: 10757 (4,156.69 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 168886272 (65.26 millions per sec)
cancelled_write_bytes: 167989248 (64.91 millions per sec)

Check file_select_array: time: 2.913064956665 - PASS
rchar: 3015590353 (1,035.20 millions per sec)
wchar: 200834864 (68.94 millions per sec)
syscr: 159738 (54,835.03 per sec)
syscw: 10926 (3,750.69 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 201039872 (69.01 millions per sec)
cancelled_write_bytes: 200429568 (68.80 millions per sec)

Check file_search_line: time: 4.3936989307404 - PASS
rchar: 11316432550 (2,575.60 millions per sec)
wchar: 156442077 (35.61 millions per sec)
syscr: 945901 (215,285.80 per sec)
syscw: 10288 (2,341.54 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 156622848 (35.65 millions per sec)
cancelled_write_bytes: 153374720 (34.91 millions per sec)

Check file_select_line: time: 1.8514518737793 - PASS
rchar: 788399017 (425.83 millions per sec)
wchar: 183793222 (99.27 millions per sec)
syscr: 90337 (48,792.52 per sec)
syscw: 11600 (6,265.35 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 184012800 (99.39 millions per sec)
cancelled_write_bytes: 179003392 (96.68 millions per sec)

Check file_pop_line: time: 2.42817902565 - PASS
rchar: 701572972 (288.93 millions per sec)
wchar: 426354213 (175.59 millions per sec)
syscr: 87071 (35,858.56 per sec)
syscw: 25176 (10,368.26 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 430428160 (177.26 millions per sec)
cancelled_write_bytes: 433696768 (178.61 millions per sec)

Check file_callback_line: time: 1.5504369735718 - PASS
rchar: 193445776 (124.77 millions per sec)
wchar: 172226656 (111.08 millions per sec)
syscr: 20351 (13,125.98 per sec)
syscw: 10386 (6,698.76 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 172425216 (111.21 millions per sec)
cancelled_write_bytes: 172916736 (111.53 millions per sec)

```

Тест функций представляет собой комплексную проверку их работы с различными входными данными и режимами. Вот краткое описание теста с анализом:


Характеристики теста:
- Цель: Проверить корректность работы функций при различных условиях.
- Методика: Использование цикла для многократного тестирования функции с разными параметрами.
- Параметры теста: Размер буфера, количество вставок строк, выравнивание и режимы работы функции.

Процесс тестирования:
- Удаление существующего файла перед каждым тестом.
- Генерация случайных значений для параметров функции.
- Вставка строк в файл с использованием функции file_insert_line.
- Проверка результатов работы функций в разных режимах.

Результаты:
- Успех: Если все проверки пройдены, тест считается успешным.
- Неудача: Любое несоответствие в результате работы функции приводит к провалу теста.


Анализ результатов:
- Время выполнения теста и статистика ввода/вывода измеряются для оценки производительности и пропускной способности.
- Результаты выводятся в консоль с указанием времени выполнения и статуса прохождения теста.

Анализ сходимости:

Тест проверяет сходимость данных, извлеченных функциями из файла, с данными, которые были вставлены в файл. Сходимость означает, что извлеченные данные точно соответствуют вставленным данным без ошибок.
Для анализа сходимости используются различные режимы функций, каждый из которых проверяет определенные аспекты данных (например, счетчик строк, смещение строки, длину строки и саму строку).

Цель анализа сходимости:

Цель состоит в том, чтобы убедиться, что функции надежно работают в различных условиях и правильно обрабатывает данные, что критически важно для стабильности и надежности системы, использующей эту функцию.

Что показывает тест:

Если тест проходит, это показывает, что функция работает корректно.
Время выполнения теста и статистика ввода/вывода позволяют оценить производительность и совокупную пропускную способность функций.
Если тест не проходит, выводится сообщение об ошибке, что указывает на проблемы в работе функции.

Таким образом, тест не только проверяет корректность работы функции, но и предоставляет данные о её производительности, что может быть использовано для оптимизации и улучшения кода.

Выводы:
Тест показывает, что функции работают корректно при различных условиях и настройках. 

Для более глубокого анализа и оптимизации производительности может потребоваться дополнительное профилирование и тестирование в различных средах выполнения. Это поможет выявить потенциальные узкие места и оптимизировать работу функции для разных типов нагрузок и размеров данных.

Подробнее в разделе: [Авто тест базы данных](/test/auto_test.md)



## Стоимость вызовов

Таблица стоимости вызова функции по возрастанию:

- file_select_line Очень низкое потребление, посекторное чтение отрезка файла.
- file_update_line Очень низкое потребление, посекторная запись отрезка файла.
- file_insert_line Очень низкое потребление, запись строки в конец файла.
- file_select_array Среднее потребление, низкое при линейном чтении или если окно файла в буфере.
- file_update_array Среднее потребление, низкое при линейной записи или если окно файла в буфере.
- file_pop_line Низкое потребление, с выравниванием очень низкое, чтение файла с конца, усечение файла.
- file_push_data Низкое потребление, запись строки в конец файла индекса и блока в конец файла данных.
- file_search_line Среднее потребление, чтение всего файла.
- file_search_array Среднее потребление, чтение всего файла.
- file_analize Среднее потребление, чтение всего файла.
- file_get_keys Среднее потребление, чтение всего файла.
- file_erase_line Среднее потребление, чтение всего файла, запись строки в файл.
- file_search_data Среднее потребление, чтение всего файла индекса и блока файла данных.
- file_defrag_lines Очень высокое потребление, полное чтение\запись всего файла.
- file_replace_line Очень высокое потребление, полное чтение\запись всего файла.
- file_defrag_data Очень высокое потребление, полное чтение\запись файлов индекса и данных.


#### Примеры

- [Тесты](test/readme.md)
- [Пример SQL адаптера](test/mysql-adapter/readme.md)
