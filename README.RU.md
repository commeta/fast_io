# Fast_IO - Расширение для PHP 8 (BETA)

## Описание

Fast_IO - это высокопроизводительное расширение для PHP 8, разработанное для эффективной работы с файлами данных. Оно предлагает набор функций для чтения, записи, обновления и удаления пар ключ-значение в файлах данных, используя низкоуровневый посекторный доступ и механизмы блокировки для синхронизации доступа. Это расширение идеально подходит для работы с большими объемами данных, обеспечивая высокую скорость и эффективность операций благодаря оптимизированному управлению памятью и дисковым вводом-выводом.

## Основные возможности

- **Быстрая запись и чтение**: Позволяет выполнять операции записи и чтения для строк с высокой производительностью.
- **Транзакции с блокировкой**: Использует механизм портируемой блокировки файла для обеспечения синхронизации доступа между параллельными операциями.
- **Эффективное управление памятью**: Чтение данных осуществляется порциями, что предотвращает переполнение памяти при работе с большими файлами.
- **Поддержка индексных файлов**: Улучшает производительность поиска по ключу за счет использования отдельных индексных файлов.
- **Бинарная безопасность**: Функции с постфиксом data обеспечивают безопасную работу с бинарными данными.

## Функции расширения
- [file_callback_line](/docs/file_callback_line.md) - Построчное чтение файла с функцией обратного вызова.
- [file_insert_line](/docs/file_insert_line.md) - Вставка строк с выравниванием в файл.
- [file_pop_line](/docs/file_pop_line.md) - Извлечение и удаление последней строки из файла.
- [file_defrag_data](/docs/file_defrag_data.md) - Дефрагментация файла данных и соответствующего индексного файла.
- [file_push_data](/docs/file_push_data.md) - Добавление порции бинарных данных файл данных и соответствующий индексный файл.
- [file_search_data](/docs/file_search_data.md) - Поиск порции бинарных данных по ключу, с использованием индексного файла.
- [file_erase_line](/docs/file_erase_line.md) - Стереть строку файле данных.
- [file_search_line](/docs/file_search_line.md) - Поиск строки по ключу в файле данных, возвращает строку.
- [file_search_array](/docs/file_search_array.md) - Поиск строк по ключу в файле данных, возвращает массив.
- [file_defrag_lines](/docs/file_defrag_lines.md) - Удаление строк из файла данных.
- [file_get_keys](/docs/file_get_keys.md) - Извлечение уникальных ключей из текстового файла.
- [file_replace_line](/docs/file_replace_line.md) - Замена строки по ключу.
- [file_select_line](/docs/file_select_line.md) - Выборка строки из файла, по указанному номеру или смещению.
- [file_select_array](/docs/file_select_array.md) - Массовая выборка строк из файла, по указанному смещению и размеру.
- [file_update_line](/docs/file_update_line.md) - Обновление строки в файле, по указанному смещению и размеру.
- [file_update_array](/docs/file_update_array.md) - Массовое обновление строк в файле.
- [file_analize](/docs/file_analize.md) - Возвращает статистику для анализа данных и диагностики файла.
- [replicate_file](/docs/replicate_file.md) - Репликация файла данных.


## Особенности реализации

- Все функции используют UNIX портируемую блокировку файла на запись, что гарантирует целостность данных при параллельном доступе [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).
- Расширение разработано без использования сторонних фреймворков и библиотек, обеспечивая высокую производительность и совместимость с PHP 8.
- Функции производят чтение данных порциями, оптимизируя использование памяти и уменьшая нагрузку на систему.
- Стоимость вызовов функций с низким потреблением в случае попадания в кэш, сопоставима со скоростью доступа к кэш памяти.

Fast_IO представляет собой мощное расширение для PHP 8, которое значительно упрощает и ускоряет работу с большими объемами данных. Благодаря эффективным механизмам чтения, записи, блокировки и управления памятью, разработчики могут создавать высокопроизводительные приложения, оптимизированные для обработки файлов данных.

### Структура файла
Строка line делится на подстроки: line_key, line_value.

Ключом line_key может быть любой печатный символ, зарезервированные символы: 
- ASCII Code 32 space (пробел) - разделитель подстрок.
- ASCII Code 127 delete (не печатный) - метка пустого кадра, ставится в начале строки заполненной пробелами.
- ASCII Code 10 line feed (перевод строки) - разделитель строк.
- ASCII Code 0 null character (нулевой символ) - разделитель подстрок.

Функции: file_defrag_data, file_defrag_lines, file_erase_line, file_get_keys, file_push_data, file_replace_line, file_search_data - при индексации строк проводят анализ первой подстроки, рассматривая любой печатный символ как ключ строки. Ключ всегда должен заканчиваться пробелом.

### Поведение Fast_IO функции при аварийном завершении транзакции
- file_push_data, file_insert_line - всегда отменяют последнюю запись и выходят с ошибкой.
- file_replace_line, file_defrag_data, file_defrag_line - в случае ошибки записи при обратном копировании, делает переименование временных файлов и данные остаются целы. Если параллельная копия Fast_IO функции ожидает снятия блокировки файла, то она завершится с ошибкой блокировки.
- file_erase_line - проверяет количество записанных байт, в случае ошибки записи файла (-3) эту операцию не отменить!
- file_update_line, file_update_array - проверяет количество записанных байт, в случае ошибки записи файла (-4) эту операцию не отменить!

Ошибка при записи в функциях file_update_line, file_update_array может возникнуть при обновлении последних секторов файла если закончилось место на диске, а длина строки выходит за пределы файла.

Ошибка записи в функции file_erase_line может говорить только об отказе оборудования.


### Регулярные выражения PCRE2

Версия на момент разработки PCRE2 10.42

В Fast_IO Engine реализована функция find_matches_pcre2, во всех функциях чтения файла подсистема PCRE2 инициализируется однократно при массовых операциях, это позволяет сэкономить системные ресурсы на инициализацию и компиляцию паттернов.

- [Краткий обзор лучших и быстрых типов регулярных выражений в PHP8](/docs/find_matches_pcre2.md)
- [Perl-compatible Regular Expressions (revised API: PCRE2)](https://pcre2project.github.io/pcre2/doc/html/index.html)



## Примеры использования

Для каждой функции расширения Fast_IO предоставлены подробные описания с примерами на PHP. Эти примеры помогут разработчикам быстро начать работу с расширением и эффективно использовать его возможности в своих проектах.

## Параметры

buffer_size - это параметр конфигурации, определяющий размер буфера для операций чтения\записи. Указание оптимального размера буфера может значительно улучшить производительность при работе с большими объемами данных.

#### Установка через php.ini

Для настройки размера буфера в глобальной конфигурации PHP добавьте или измените следующую строку в файле php.ini:

fast_io.buffer_size = 4096 // От 16 байт

Значение указывается в байтах. По умолчанию размер буфера установлен равным 4096 байт (4 КБ).

#### Использование в коде PHP

Вы можете получить текущее значение buffer_size или установить новое значение в начале вашего PHP скрипта:
```
// Получить текущий размер буфера
$currentBufferSize = ini_get('fast_io.buffer_size');

// Установить новый размер буфера, до вызова функций!
ini_set('fast_io.buffer_size', 8192); // 8 КБ
```

#### Инициализация

Инициализация параметров в PHP происходит во время запуска сервера или выполнения скрипта. В приведенном примере кода инициализация параметра "fast_io.buffer_size" осуществляется при инициализации модуля fast_io в PHP.

### Примечания
- Изменение размера буфера во время выполнения скрипта может повлиять на производительность операций ввода-вывода, выполняемых после этого изменения.
- Выбор оптимального размера буфера зависит от конкретных задач и условий работы приложения. Рекомендуется проводить тестирование с различными значениями, чтобы найти наилучший вариант.
- Указывайте размер буфера ориентируясь на размер порции данных, значения по умолчанию 4096 достаточно для работы со строками размером 4096 байт.
- При большом размере буфера возможны лишние чтения файла, например при полнотекстовом поиске, когда значение может быть найдено в начале файла, а он будет прочитан на величину буфера.
- При очень низком размере буфера, количество запросов на чтение\запись может существенно вырасти, что создаст дополнительную нагрузку. 
- В операциях поиска строк создается динамический буфер dynamic_buffer по принципу dynamic_buffer_size += buffer_size. Размер динамического буфера будет установлен на величину максимального всплеска размера строки.
- Если размер файла меньше buffer_size, то buffer_size уменьшается до размера файла.

dynamic_buffer используется для хранения частей файла, считываемых в память для поиска определенного ключа или выполнения сопоставления с регулярным выражением. Работа dynamic_buffer основана на следующих принципах:

### Как Работает dynamic_buffer

1. **Инициализация и Размер**: Буфер инициализируется с начальным размером, определенным значением fast_io.buffer_size.

2. **Чтение из Файла**: Данные считываются из файла блоками размером fast_io.buffer_size и добавляются в dynamic_buffer. В режиме поиска строк, если строка не помещается в текущий размер буфера, dynamic_buffer увеличивается на размер fast_io.buffer_size на каждой итерации чтения из файла.

3. **Увеличение Размера**: Размер dynamic_buffer увеличивается на ini_buffer_size. Увеличение происходит с помощью функции erealloc, которая пытается изменить размер уже выделенной памяти, сохраняя при этом существующие данные.


### Использование системного буфера C

Когда вы работаете с файловыми операциями, такими как чтение из файла с помощью буферных функции, используется системный буфер. Этот буфер служит промежуточным хранилищем данных между физическим файлом на диске и оперативной памятью компьютера. Системный буфер позволяет оптимизировать ввод-вывод за счет минимизации количества обращений к диску, что значительно увеличивает производительность операций чтения и записи.

В процессе работы системный буфер используется для временного хранения данных, считанных из файла, перед тем как они будут помещены в пользовательский буфер (dynamic_buffer). Это позволяет эффективно читать данные большими блоками, что уменьшает количество обращений к диску.

Системные функции чтения и записи используют внутренний буфер для оптимизации операций ввода-вывода. Даже если вы запрашиваете чтение или запись всего одного байта, эти функции обычно считывают или записывают данные блоками.

Когда вы запрашиваете чтение 1 байта, системная функция может считать из файла целый блок данных и сохранить его во внутреннем буфере. При последующих вызовах чтение данных будет возвращаться из этого буфера, что уменьшает количество обращений к ядру операционной системы и ускоряет процесс чтения.

Аналогично, при запросе записи 1 байта, данные сначала помещаются во внутренний буфер. Когда буфер заполняется или когда файл закрывается, данные из буфера записываются в файл.

Размер блока (blocksize) зависит от системы и может быть различным. Во многих системах размер блока составляет 4096 байт (4 КБ) или 8192 байта (8 КБ), но это не жёстко заданное значение и может отличаться в зависимости от файловой системы и конкретной операционной системы.


### Преимущества использования системного буфера C

1. **Эффективность**: Чтение данных большими блоками и их временное хранение в системном буфере уменьшает нагрузку на дисковую систему и повышает общую производительность операций ввода-вывода.

2. **Уменьшение Задержек**: Минимизация обращений к диску снижает задержки, связанные с механическими особенностями работы жестких дисков и особенностями работы солид-стейт дисков (SSD).


### Использование системного кэша ядра Linux

Когда функция запрашивает данные из файла, системный кэш ядра Linux играет ключевую роль в оптимизации производительности при обращении к данным на диске.

### Как работает системный кэш ядра Linux:

1. **Чтение данных**: Когда функция пытается прочитать данные из файла, операционная система сначала проверяет, находятся ли эти данные в системном кэше (кэше страниц ядра). Если данные уже есть в кэше, они могут быть немедленно предоставлены процессу без необходимости обращения к физическому диску.

2. **Кэширование данных**: Если запрашиваемые данные отсутствуют в кэше, ядро загружает эти данные с диска в системный кэш перед их предоставлением процессу. При этом, данные загружаются блоками, что повышает эффективность последующих обращений к этим же данным.

3. **Запись данных**: При записи данных в файл, данные сначала помещаются в системный кэш, и только потом, в зависимости от политики кэширования и активности системы, они могут быть записаны на физический носитель. Это позволяет уменьшить количество операций записи на диск, что положительно сказывается на сроке службы диска и производительности системы.

### Преимущества использования системного кэша:

- **Уменьшение задержек**: Доступ к данным из кэша значительно быстрее доступа к данным с физического диска, что уменьшает время выполнения операций чтения/записи.
- **Оптимизация работы с диском**: Кэширование позволяет сократить количество обращений к диску за счет предварительного чтения и отложенной записи, что повышает общую производительность системы.
- **Повышение пропускной способности**: Системный кэш позволяет обрабатывать больше операций ввода-вывода за единицу времени благодаря уменьшению количества фактических обращений к диску.

Использование системного кэша ядра Linux помогает ускорить процесс поиска значений в файле, особенно если файл часто используется или его размер превышает размер оперативной памяти. Это делает чтение данных более эффективным и уменьшает общее время выполнения функции.


### Упреждающее чтение (Read-Ahead)

Упреждающее чтение — это метод, используемый операционными системами и файловыми системами, для увеличения производительности чтения данных с диска. ОС заранее читает с диска больше данных, чем было запрошено приложением, предполагая, что эти данные скоро понадобятся. Это уменьшает количество обращений к диску и увеличивает скорость чтения данных.

При чтении данных упреждающее чтение может быть неявно использовано через механизмы ОС и файловой системы, когда вы выполняете запрос для чтения блоков данных из файла. ОС может заранее загружать данные в системный буфер, ускоряя доступ к последующим блокам данных.

### Оптимизация записи на диск

**Задержанная запись (Write-Back Caching)**: При записи данных они сначала помещаются в буфер (кэш) в памяти, а не сразу записываются на диск. Запись на физический носитель происходит позже, в более удобное время. Это уменьшает количество операций записи на диск, что положительно сказывается на производительности и сроке службы диска.


---

## Установка

### Шаг 1: Создание каркаса расширения
Скопируйте файлы: `config.m4`, `fast_io.c`, `fast_io.h` в текущий каталог проекта.

Для начала, вам нужно создать каркас вашего расширения. Это можно сделать вручную или с помощью инструмента ext_skel в исходниках PHP. Например:
```
phpize
./configure
make
make test
```

Это создаст базовую структуру для вашего расширения.



### Шаг 2: Компиляция и тестирование

Вам нужно скомпилировать расширение и протестировать его. Используйте phpize, ./configure, make и make test для компиляции и установки вашего расширения.

После установки не забудьте добавить строку `extension=fast_io.so` в ваш `php.ini`, чтобы активировать расширение.

Теперь вы можете вызывать новые функции из PHP как обычные функции.

Результат тестирования: Ubuntu 24.04, Ryzen 12 Cores, 16GB RAM, SATA 3 SSD.
**test/test.php**
```
file_insert_line: 0.10697793960571 (0.00001070)
file_search_line: 2.9135210514069 (0.00029135)
file_search_line repeat: 0.084739208221436 (0.00000847)
file_defrag_lines: 0.65570092201233 (0.00006557)
file_push_data: 0.21720695495605 (0.00002172)
file_search_data: 2.353935956955 (0.00023539)
file_search_data repeat: 0.15796780586243 (0.00001580)
file_pop_line: 0.24059700965881 (0.00002406)
```

Функция запускалась в цикле 10000 раз, с линейным инкрементом индекса (без попадания в кэш) и repeat многократный поиск одного и того же индекса.
Показано время в секундах по результатам теста: 10000 запусков (1 запуск).


**test/auto_test.php**
```
Check file_insert_line: time: 2.4393680095673 - PASS
rchar: 721840850 (2,367,304,472.86 MB/s)
wchar: 190374266 (624,339,633.06 MB/s)
syscr: 84525 (277,202.95 MB/s)
syscw: 10755 (35,271.43 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 190595072 (625,063,774.72 MB/s)
cancelled_write_bytes: 183947264 (603,262,036.00 MB/s)

Check file_analize: time: 4.3009340763092 - PASS
rchar: 6013737818 (11,185,919,544.55 MB/s)
wchar: 179922634 (334,667,085.44 MB/s)
syscr: 577291 (1,073,796.51 MB/s)
syscw: 10521 (19,569.70 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 180121600 (335,037,174.35 MB/s)
cancelled_write_bytes: 178229248 (331,517,284.08 MB/s)

Check file_get_keys: time: 2.4806950092316 - PASS
rchar: 1205542122 (3,887,756,028.09 MB/s)
wchar: 200729870 (647,334,297.05 MB/s)
syscr: 118137 (380,980.33 MB/s)
syscw: 11213 (36,160.83 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 200941568 (648,017,002.50 MB/s)
cancelled_write_bytes: 197926912 (638,295,030.27 MB/s)

Check file_search_array: time: 3.7282540798187 - PASS
rchar: 1846043100 (3,961,195,906.67 MB/s)
wchar: 153640688 (329,678,578.15 MB/s)
syscr: 205735 (441,461.33 MB/s)
syscw: 10320 (22,144.41 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 153853952 (330,136,195.03 MB/s)
cancelled_write_bytes: 153202688 (328,738,728.04 MB/s)

Check file_select_array: time: 2.9537951946259 - PASS
rchar: 2497627602 (6,764,524,789.11 MB/s)
wchar: 166315040 (450,444,337.65 MB/s)
syscr: 150678 (408,093.29 MB/s)
syscw: 10488 (28,405.49 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 166531072 (451,029,434.41 MB/s)
cancelled_write_bytes: 164159488 (444,606,283.60 MB/s)

Check file_search_line: time: 7.2284481525421 - PASS
rchar: 15166284068 (16,785,106,565.55 MB/s)
wchar: 197594237 (218,685,098.47 MB/s)
syscr: 1544095 (1,708,908.99 MB/s)
syscw: 11436 (12,656.66 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 197804032 (218,917,286.62 MB/s)
cancelled_write_bytes: 196804608 (217,811,185.86 MB/s)

Check file_select_line: time: 2.2228870391846 - PASS
rchar: 827814895 (2,979,242,329.12 MB/s)
wchar: 195400780 (703,232,423.62 MB/s)
syscr: 91489 (329,261.90 MB/s)
syscw: 11764 (42,337.73 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 195616768 (704,009,747.87 MB/s)
cancelled_write_bytes: 191799296 (690,270,958.87 MB/s)

Check file_pop_line - ERROR
rchar: 588882265 (319,688,924.84 MB/s)
wchar: 339546583 (184,331,042.90 MB/s)
syscr: 69950 (37,974.04 MB/s)
syscw: 17017 (9,238.09 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 339828736 (184,484,216.45 MB/s)
cancelled_write_bytes: 340869120 (185,049,013.97 MB/s)

Check file_callback_line: time: 2.0378620624542 - PASS
rchar: 218743187 (858,716,361.74 MB/s)
wchar: 195721830 (768,341,817.07 MB/s)
syscr: 22283 (87,475.99 MB/s)
syscw: 11282 (44,289.55 MB/s)
read_bytes: 0 (0.00 MB/s)
write_bytes: 195928064 (769,151,426.33 MB/s)
cancelled_write_bytes: 196296704 (770,598,590.03 MB/s)
root@api:/home/commeta/project/kernel/fast_io# 
```

Подробнее в разделе: [Авто тест базы данных](/test/auto_test.md)



## Стоимость вызовов

Таблица стоимости вызова функции по возрастанию:

- file_select_line Очень низкое потребление, посекторное чтение отрезка файла.
- file_update_line Очень низкое потребление, посекторная запись отрезка файла.
- file_insert_line Очень низкое потребление, запись строки в конец файла.
- file_select_array Среднее потребление, низкое при линейном чтении или если окно файла в буфере.
- file_update_array Среднее потребление, низкое при линейной записи или если окно файла в буфере.
- file_pop_line Низкое потребление, с выравниванием очень низкое, чтение файла с конца, усечение файла.
- file_push_data Низкое потребление, запись строки в конец файла индекса и блока в конец файла данных.
- file_search_line Среднее потребление, чтение всего файла.
- file_search_array Среднее потребление, чтение всего файла.
- file_analize Среднее потребление, чтение всего файла.
- file_get_keys Среднее потребление, чтение всего файла.
- file_erase_line Среднее потребление, чтение всего файла, запись строки в файл.
- file_search_data Среднее потребление, чтение всего файла индекса и блока файла данных.
- file_defrag_lines Очень высокое потребление, полное чтение\запись всего файла.
- file_replace_line Очень высокое потребление, полное чтение\запись всего файла.
- file_defrag_data Очень высокое потребление, полное чтение\запись файлов индекса и данных.


#### Примеры

- [Тесты](test/readme.md)
- [Пример SQL адаптера](test/mysql-adapter/readme.md)
