# Fast_IO - Расширение для PHP 8 (BETA)

![Fast_IO Extension for PHP 8](https://raw.githubusercontent.com/commeta/fast_io/refs/heads/main/test/auto_test_profile_mem.png "fast_io")

## Описание

Fast_IO - это высокопроизводительное расширение для PHP 8, разработанное для эффективной работы с файлами данных. Оно предлагает набор функций для чтения, записи, обновления и удаления пар ключ-значение в файлах данных, используя низкоуровневый посекторный доступ и механизмы блокировки для синхронизации доступа. Это расширение идеально подходит для работы с большими объемами данных, обеспечивая высокую скорость и эффективность операций благодаря оптимизированному управлению памятью и дисковым вводом-выводом.

### Основные возможности

- **Быстрая запись и чтение**: Позволяет выполнять операции записи и чтения для строк с высокой производительностью.
- **Транзакции с блокировкой**: Использует механизм портируемой блокировки файла для обеспечения синхронизации доступа между параллельными операциями.
- **Эффективное управление памятью**: Чтение данных осуществляется порциями, что предотвращает переполнение памяти при работе с большими файлами.
- **Поддержка индексных файлов**: Улучшает производительность поиска по ключу за счет использования отдельных индексных файлов.
- **Бинарная безопасность**: Функции с постфиксом data обеспечивают безопасную работу с бинарными данными.

### Функции расширения
- [file_callback_line](/docs/file_callback_line.md) - Построчное чтение файла с функцией обратного вызова.
- [file_insert_line](/docs/file_insert_line.md) - Вставка строк с выравниванием в файл.
- [file_pop_line](/docs/file_pop_line.md) - Извлечение и удаление последней строки из файла.
- [file_defrag_data](/docs/file_defrag_data.md) - Дефрагментация файла данных и соответствующего индексного файла.
- [file_push_data](/docs/file_push_data.md) - Добавление порции бинарных данных файл данных и соответствующий индексный файл.
- [file_search_data](/docs/file_search_data.md) - Поиск порции бинарных данных по ключу, с использованием индексного файла.
- [file_erase_line](/docs/file_erase_line.md) - Стереть строку файле данных.
- [file_search_line](/docs/file_search_line.md) - Поиск строки по ключу в файле данных, возвращает строку.
- [file_search_array](/docs/file_search_array.md) - Поиск строк по ключу в файле данных, возвращает массив.
- [file_defrag_lines](/docs/file_defrag_lines.md) - Удаление строк из файла данных.
- [file_get_keys](/docs/file_get_keys.md) - Извлечение уникальных ключей из текстового файла.
- [file_replace_line](/docs/file_replace_line.md) - Замена строки по ключу.
- [file_select_line](/docs/file_select_line.md) - Выборка строки из файла, по указанному номеру или смещению.
- [file_select_array](/docs/file_select_array.md) - Массовая выборка строк из файла, по указанному смещению и размеру.
- [file_update_line](/docs/file_update_line.md) - Обновление строки в файле, по указанному смещению и размеру.
- [file_update_array](/docs/file_update_array.md) - Массовое обновление строк в файле.
- [file_analize](/docs/file_analize.md) - Возвращает статистику для анализа данных и диагностики файла.
- [replicate_file](/docs/replicate_file.md) - Репликация файла данных.


### Особенности реализации

- Все функции используют UNIX портируемую блокировку файла на запись, что гарантирует целостность данных при параллельном доступе [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).
- Расширение разработано без использования сторонних фреймворков и библиотек, обеспечивая высокую производительность и совместимость с PHP 8.
- Функции производят чтение данных порциями, оптимизируя использование памяти и уменьшая нагрузку на систему.
- Стоимость вызовов функций с низким потреблением в случае попадания в кэш, сопоставима со скоростью доступа к кэш памяти.

Fast_IO представляет собой мощное расширение для PHP 8, которое значительно упрощает и ускоряет работу с большими объемами данных. Благодаря эффективным механизмам чтения, записи, блокировки и управления памятью, разработчики могут создавать высокопроизводительные приложения, оптимизированные для обработки файлов данных.

#### Структура файла
Строка line делится на подстроки: line_key, line_value.

Ключом line_key может быть любой печатный символ, зарезервированные символы: 
- ASCII Code 32 space (пробел) - разделитель подстрок.
- ASCII Code 127 delete (не печатный) - метка пустого кадра, ставится в начале строки заполненной пробелами.
- ASCII Code 10 line feed (перевод строки) - разделитель строк.
- ASCII Code 0 null character (нулевой символ) - разделитель подстрок.

Функции: file_defrag_data, file_defrag_lines, file_erase_line, file_get_keys, file_push_data, file_replace_line, file_search_data - при индексации строк проводят анализ первой подстроки, рассматривая любой печатный символ как ключ строки. Ключ всегда должен заканчиваться пробелом.


#### Поддержка ACID-транзакций

ACID — это набор правил, которому должна следовать база данных для обеспечения корректности выполнения транзакций.

Аббревиатура ACID расшифровывается следующим образом:
- Атомарность (Atomicity) — каждая транзакция является неделимой и выполняется полностью или не выполняется вообще.
- Согласованность (Consistency) — транзакция не должна нарушать ограничений целостности базы данных.
- Изолированность (Isolation) — транзакции не должны влиять друг на друга.
- Долговечность (Durability) — после успешного завершения транзакции все изменения должны сохраниться, даже в случае сбоя.


Fast_IO использует UNIX механизм портируемой блокировки файла с помощью функции flock - для обеспечения синхронизации доступа между параллельными операциями.

Функция flock в Linux предназначена для блокировки файлов на уровне ядра операционной системы. Эта функция предоставляет возможность процессу установить блокировку на файл, которая предотвратит его изменение другими процессами до тех пор, пока текущий процесс не снимет эту блокировку.

Если функция Fast_IO пытается прочитать или записать в файл, который имеет установленную блокировку flock LOCK_EX, операция будет ожидать освобождения блокировки параллельным процессом.

Блокировка flock действует до тех пор, пока процесс, установивший её, не вызовет flock LOCK_UN для снятия блокировки или не закроет файл. Если процесс завершается без снятия блокировки, она автоматически снимается.


Важно отметить, что сама по себе блокировка flock не является транзакционной, то есть не поддерживает ACID-транзакции. Если процесс, установивший блокировку, завершится с ошибкой, данные могут остаться в несогласованном состоянии. Поэтому flock обычно используется для реализации простых синхронизационных механизмов, а не для обеспечения целостности данных.

Подробнее: [Блокировки в Linux](#блокировки-в-linux).


##### Обеспечение целостности данных

- file_push_data, file_insert_line - всегда отменяют последнюю запись и выходят с ошибкой.
- file_replace_line, file_defrag_data, file_defrag_line - в случае ошибки записи при обратном копировании, делает переименование временных файлов и данные остаются целы. Если параллельная копия Fast_IO функции ожидает снятия блокировки файла, то она завершится с ошибкой блокировки.
- file_erase_line - проверяет количество записанных байт, в случае ошибки записи файла (-3) эту операцию не отменить!
- file_update_line, file_update_array - проверяет количество записанных байт, в случае ошибки записи файла (-4) эту операцию не отменить!

Ошибка при записи в функциях file_update_line, file_update_array может возникнуть при обновлении последних секторов файла если закончилось место на диске, а длина строки выходит за пределы файла.

Ошибка записи в функции file_erase_line может говорить только об отказе оборудования.




#### Регулярные выражения PCRE2

Версия на момент разработки PCRE2 10.42

В Fast_IO Engine реализована функция find_matches_pcre2, во всех функциях чтения файла подсистема PCRE2 инициализируется однократно при массовых операциях, это позволяет сэкономить системные ресурсы на инициализацию и компиляцию паттернов.

- [Краткий обзор лучших и быстрых типов регулярных выражений в PHP8](/docs/find_matches_pcre2.md)
- [Perl-compatible Regular Expressions (revised API: PCRE2)](https://pcre2project.github.io/pcre2/doc/html/index.html)



### Примеры использования

Для каждой функции расширения Fast_IO предоставлены подробные описания с примерами на PHP. Эти примеры помогут разработчикам быстро начать работу с расширением и эффективно использовать его возможности в своих проектах.

### Параметры

buffer_size - это параметр конфигурации, определяющий размер буфера для операций чтения\записи. Указание оптимального размера буфера может значительно улучшить производительность при работе с большими объемами данных.

#### Установка через php.ini

Для настройки размера буфера в глобальной конфигурации PHP добавьте или измените следующую строку в файле php.ini:

fast_io.buffer_size = 4096 // От 16 байт

Значение указывается в байтах. По умолчанию размер буфера установлен равным 4096 байт (4 КБ).

#### Использование в коде PHP

Вы можете получить текущее значение buffer_size или установить новое значение в начале вашего PHP скрипта:
```
// Получить текущий размер буфера
$currentBufferSize = ini_get('fast_io.buffer_size');

// Установить новый размер буфера, до вызова функций!
ini_set('fast_io.buffer_size', 8192); // 8 КБ
```

#### Инициализация

Инициализация параметров в PHP происходит во время запуска сервера или выполнения скрипта. В приведенном примере кода инициализация параметра "fast_io.buffer_size" осуществляется при инициализации модуля fast_io в PHP.

#### Примечания
- Изменение размера буфера во время выполнения скрипта может повлиять на производительность операций ввода-вывода, выполняемых после этого изменения.
- Выбор оптимального размера буфера зависит от конкретных задач и условий работы приложения. Рекомендуется проводить тестирование с различными значениями, чтобы найти наилучший вариант.
- Указывайте размер буфера ориентируясь на размер порции данных, значения по умолчанию 4096 достаточно для работы со строками размером 4096 байт.
- При большом размере буфера возможны лишние чтения файла, например при полнотекстовом поиске, когда значение может быть найдено в начале файла, а он будет прочитан на величину буфера.
- При очень низком размере буфера, количество запросов на чтение\запись может существенно вырасти, что создаст дополнительную нагрузку. 
- В операциях поиска строк создается динамический буфер dynamic_buffer по принципу dynamic_buffer_size += buffer_size. Размер динамического буфера будет установлен на величину максимального всплеска размера строки.
- Если размер файла меньше buffer_size, то buffer_size уменьшается до размера файла.

dynamic_buffer используется для хранения частей файла, считываемых в память для поиска определенного ключа или выполнения сопоставления с регулярным выражением. Работа dynamic_buffer основана на следующих принципах:

#### Как Работает dynamic_buffer

1. **Инициализация и Размер**: Буфер инициализируется с начальным размером, определенным значением fast_io.buffer_size.

2. **Чтение из Файла**: Данные считываются из файла блоками размером fast_io.buffer_size и добавляются в dynamic_buffer. В режиме поиска строк, если строка не помещается в текущий размер буфера, dynamic_buffer увеличивается на размер fast_io.buffer_size на каждой итерации чтения из файла.

3. **Увеличение Размера**: Размер dynamic_buffer увеличивается на ini_buffer_size. Увеличение происходит с помощью функции erealloc, которая пытается изменить размер уже выделенной памяти, сохраняя при этом существующие данные.


#### Использование системного буфера C

Когда вы работаете с файловыми операциями, такими как чтение из файла с помощью буферных функции, используется системный буфер. Этот буфер служит промежуточным хранилищем данных между физическим файлом на диске и оперативной памятью компьютера. Системный буфер позволяет оптимизировать ввод-вывод за счет минимизации количества обращений к диску, что значительно увеличивает производительность операций чтения и записи.

В процессе работы системный буфер используется для временного хранения данных, считанных из файла, перед тем как они будут помещены в пользовательский буфер (dynamic_buffer). Это позволяет эффективно читать данные большими блоками, что уменьшает количество обращений к диску.

Системные функции чтения и записи используют внутренний буфер для оптимизации операций ввода-вывода. Даже если вы запрашиваете чтение или запись всего одного байта, эти функции обычно считывают или записывают данные блоками.

Когда вы запрашиваете чтение 1 байта, системная функция может считать из файла целый блок данных и сохранить его во внутреннем буфере. При последующих вызовах чтение данных будет возвращаться из этого буфера, что уменьшает количество обращений к ядру операционной системы и ускоряет процесс чтения.

Аналогично, при запросе записи 1 байта, данные сначала помещаются во внутренний буфер. Когда буфер заполняется или когда файл закрывается, данные из буфера записываются в файл.

Размер блока (blocksize) зависит от системы и может быть различным. Во многих системах размер блока составляет 4096 байт (4 КБ) или 8192 байта (8 КБ), но это не жёстко заданное значение и может отличаться в зависимости от файловой системы и конкретной операционной системы.


#### Преимущества использования системного буфера C

1. **Эффективность**: Чтение данных большими блоками и их временное хранение в системном буфере уменьшает нагрузку на дисковую систему и повышает общую производительность операций ввода-вывода.

2. **Уменьшение Задержек**: Минимизация обращений к диску снижает задержки, связанные с механическими особенностями работы жестких дисков и особенностями работы солид-стейт дисков (SSD).


#### Использование системного кэша ядра Linux

Когда функция запрашивает данные из файла, системный кэш ядра Linux играет ключевую роль в оптимизации производительности при обращении к данным на диске.

#### Как работает системный кэш ядра Linux:

1. **Чтение данных**: Когда функция пытается прочитать данные из файла, операционная система сначала проверяет, находятся ли эти данные в системном кэше (кэше страниц ядра). Если данные уже есть в кэше, они могут быть немедленно предоставлены процессу без необходимости обращения к физическому диску.

2. **Кэширование данных**: Если запрашиваемые данные отсутствуют в кэше, ядро загружает эти данные с диска в системный кэш перед их предоставлением процессу. При этом, данные загружаются блоками, что повышает эффективность последующих обращений к этим же данным.

3. **Запись данных**: При записи данных в файл, данные сначала помещаются в системный кэш, и только потом, в зависимости от политики кэширования и активности системы, они могут быть записаны на физический носитель. Это позволяет уменьшить количество операций записи на диск, что положительно сказывается на сроке службы диска и производительности системы.

#### Преимущества использования системного кэша:

- **Уменьшение задержек**: Доступ к данным из кэша значительно быстрее доступа к данным с физического диска, что уменьшает время выполнения операций чтения/записи.
- **Оптимизация работы с диском**: Кэширование позволяет сократить количество обращений к диску за счет предварительного чтения и отложенной записи, что повышает общую производительность системы.
- **Повышение пропускной способности**: Системный кэш позволяет обрабатывать больше операций ввода-вывода за единицу времени благодаря уменьшению количества фактических обращений к диску.

Использование системного кэша ядра Linux помогает ускорить процесс поиска значений в файле, особенно если файл часто используется или его размер превышает размер оперативной памяти. Это делает чтение данных более эффективным и уменьшает общее время выполнения функции.


#### Упреждающее чтение (Read-Ahead)

Упреждающее чтение — это метод, используемый операционными системами и файловыми системами, для увеличения производительности чтения данных с диска. ОС заранее читает с диска больше данных, чем было запрошено приложением, предполагая, что эти данные скоро понадобятся. Это уменьшает количество обращений к диску и увеличивает скорость чтения данных.

При чтении данных упреждающее чтение может быть неявно использовано через механизмы ОС и файловой системы, когда вы выполняете запрос для чтения блоков данных из файла. ОС может заранее загружать данные в системный буфер, ускоряя доступ к последующим блокам данных.

#### Оптимизация записи на диск

**Задержанная запись (Write-Back Caching)**: При записи данных они сначала помещаются в буфер (кэш) в памяти, а не сразу записываются на диск. Запись на физический носитель происходит позже, в более удобное время. Это уменьшает количество операций записи на диск, что положительно сказывается на производительности и сроке службы диска.


---

### Установка

#### Шаг 1: Создание каркаса расширения
Скопируйте файлы: `config.m4`, `fast_io.c`, `fast_io.h` в текущий каталог проекта.

Для начала, вам нужно создать каркас вашего расширения. Это можно сделать вручную или с помощью инструмента ext_skel в исходниках PHP. Например:
```
phpize
./configure
make
make test
```

Это создаст базовую структуру для вашего расширения.



#### Шаг 2: Компиляция и тестирование

Вам нужно скомпилировать расширение и протестировать его. Используйте: phpize, ./configure, make и make test для компиляции и установки вашего расширения.

После установки не забудьте добавить строку `extension=fast_io.so` в ваш `php.ini`, чтобы активировать расширение.

Теперь вы можете вызывать новые функции из PHP как обычные функции.

Результат тестирования: Ubuntu 24.04, Ryzen 12 Cores, 16GB RAM, SATA 3 SSD.


**test/test.php**
```
file_insert_line: 0.10697793960571 (0.00001070)
file_search_line: 2.9135210514069 (0.00029135)
file_search_line repeat: 0.084739208221436 (0.00000847)
file_defrag_lines: 0.65570092201233 (0.00006557)
file_push_data: 0.21720695495605 (0.00002172)
file_search_data: 2.353935956955 (0.00023539)
file_search_data repeat: 0.15796780586243 (0.00001580)
file_pop_line: 0.24059700965881 (0.00002406)
```

Функция запускалась в цикле 10000 раз, с линейным инкрементом индекса (без попадания в кэш) и repeat многократный поиск одного и того же индекса.
Показано время в секундах по результатам теста: 10000 запусков (1 запуск).


**test/auto_test.php**
```
Check file_insert_line: time: 1.9269127845764 - PASS
rchar: 674020973 (349.79 millions per sec)
wchar: 174840700 (90.74 millions per sec)
syscr: 71455 (37,082.63 per sec)
syscw: 10495 (5,446.54 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 175058944 (90.85 millions per sec)
cancelled_write_bytes: 168718336 (87.56 millions per sec)

Check file_analize: time: 4.6234958171844 - PASS
rchar: 7684914475 (1,662.14 millions per sec)
wchar: 211675884 (45.78 millions per sec)
syscr: 600218 (129,819.09 per sec)
syscw: 11690 (2,528.39 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 211869696 (45.82 millions per sec)
cancelled_write_bytes: 216678400 (46.86 millions per sec)

Check file_get_keys: time: 2.1775228977203 - PASS
rchar: 1179394176 (541.62 millions per sec)
wchar: 196357512 (90.17 millions per sec)
syscr: 119811 (55,021.69 per sec)
syscw: 11056 (5,077.33 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 196562944 (90.27 millions per sec)
cancelled_write_bytes: 194015232 (89.10 millions per sec)

Check file_search_array: time: 2.6541838645935 - PASS
rchar: 2158531044 (813.26 millions per sec)
wchar: 179663771 (67.69 millions per sec)
syscr: 211077 (79,526.14 per sec)
syscw: 10118 (3,812.09 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 179859456 (67.76 millions per sec)
cancelled_write_bytes: 180285440 (67.93 millions per sec)

Check file_select_array: time: 2.4541449546814 - PASS
rchar: 2465994254 (1,004.83 millions per sec)
wchar: 164208502 (66.91 millions per sec)
syscr: 148473 (60,498.87 per sec)
syscw: 10405 (4,239.77 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 164421632 (67.00 millions per sec)
cancelled_write_bytes: 161804288 (65.93 millions per sec)

Check file_search_line: time: 5.820433139801 - PASS
rchar: 12680275214 (2,178.58 millions per sec)
wchar: 177966239 (30.58 millions per sec)
syscr: 1344481 (230,993.29 per sec)
syscw: 11131 (1,912.40 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 178176000 (30.61 millions per sec)
cancelled_write_bytes: 180559872 (31.02 millions per sec)

Check file_select_line: time: 1.6426420211792 - PASS
rchar: 702575103 (427.71 millions per sec)
wchar: 164970973 (100.43 millions per sec)
syscr: 79011 (48,099.95 per sec)
syscw: 10222 (6,222.90 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 165183488 (100.56 millions per sec)
cancelled_write_bytes: 163766272 (99.70 millions per sec)

Check file_pop_line: time: 5.3802130222321 - PASS
rchar: 1289819041 (239.73 millions per sec)
wchar: 773095295 (143.69 millions per sec)
syscr: 165699 (30,797.85 per sec)
syscw: 46892 (8,715.64 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 773881856 (143.84 millions per sec)
cancelled_write_bytes: 774709248 (143.99 millions per sec)

Check file_callback_line: time: 1.8096261024475 - PASS
rchar: 578088413 (319.45 millions per sec)
wchar: 153451752 (84.80 millions per sec)
syscr: 55345 (30,583.67 per sec)
syscw: 10048 (5,552.53 per sec)
read_bytes: 0 (0.00 millions per sec)
write_bytes: 153649152 (84.91 millions per sec)
cancelled_write_bytes: 154738688 (85.51 millions per sec)

```

Тест функций представляет собой комплексную проверку их работы с различными входными данными и режимами. Вот краткое описание теста с анализом:


Характеристики теста:
- Цель: Проверить корректность работы функций при различных условиях.
- Методика: Использование цикла для многократного тестирования функции с разными параметрами.
- Параметры теста: Размер буфера, количество вставок строк, выравнивание и режимы работы функции.

Процесс тестирования:
- Удаление существующего файла перед каждым тестом.
- Генерация случайных значений для параметров функции.
- Вставка строк в файл с использованием функции file_insert_line.
- Проверка результатов работы функций в разных режимах.

Результаты:
- Успех: Если все проверки пройдены, тест считается успешным.
- Неудача: Любое несоответствие в результате работы функции приводит к провалу теста.


Анализ результатов:
- Время выполнения теста и статистика ввода/вывода измеряются для оценки производительности и пропускной способности.
- Результаты выводятся в консоль с указанием времени выполнения и статуса прохождения теста.

Анализ сходимости:

Тест проверяет сходимость данных, извлеченных функциями из файла, с данными, которые были вставлены в файл. Сходимость означает, что извлеченные данные точно соответствуют вставленным данным без ошибок.
Для анализа сходимости используются различные режимы функций, каждый из которых проверяет определенные аспекты данных (например, счетчик строк, смещение строки, длину строки и саму строку).

Цель анализа сходимости:

Цель состоит в том, чтобы убедиться, что функции надежно работают в различных условиях и правильно обрабатывают данные, что критически важно для стабильности и надежности системы, использующей эту функцию.

Что показывает тест:

Если тест проходит, это показывает, что функция работает корректно.
Время выполнения теста и статистика ввода/вывода позволяют оценить производительность и совокупную пропускную способность функций.
Если тест не проходит, выводится сообщение об ошибке, что указывает на проблемы в работе функции.

Таким образом, тест не только проверяет корректность работы функции, но и предоставляет данные о её производительности, что может быть использовано для оптимизации и улучшения кода.

Выводы:
Тест показывает, что функции работают корректно при различных условиях и настройках. 

Для более глубокого анализа и оптимизации производительности может потребоваться дополнительное профилирование и тестирование в различных средах выполнения. Это поможет выявить потенциальные узкие места и оптимизировать работу функции для разных типов нагрузок и размеров данных.

Подробнее в разделе: [Авто тест базы данных](/test/auto_test.md)



### Стоимость вызовов

Таблица стоимости вызова функции по возрастанию:

- file_select_line Очень низкое потребление, посекторное чтение отрезка файла.
- file_update_line Очень низкое потребление, посекторная запись отрезка файла.
- file_insert_line Очень низкое потребление, запись строки в конец файла.
- file_select_array Среднее потребление, низкое при линейном чтении или если окно файла в буфере.
- file_update_array Среднее потребление, низкое при линейной записи или если окно файла в буфере.
- file_pop_line Низкое потребление, с выравниванием очень низкое, чтение файла с конца, усечение файла.
- file_push_data Низкое потребление, запись строки в конец файла индекса и блока в конец файла данных.
- file_search_line Среднее потребление, чтение всего файла.
- file_search_array Среднее потребление, чтение всего файла.
- file_analize Среднее потребление, чтение всего файла.
- file_get_keys Среднее потребление, чтение всего файла.
- file_erase_line Среднее потребление, чтение всего файла, запись строки в файл.
- file_search_data Среднее потребление, чтение всего файла индекса и блока файла данных.
- file_defrag_lines Очень высокое потребление, полное чтение\запись всего файла.
- file_replace_line Очень высокое потребление, полное чтение\запись всего файла.
- file_defrag_data Очень высокое потребление, полное чтение\запись файлов индекса и данных.


#### Примеры

- [Тесты](test/readme.md)
- [Пример SQL адаптера](test/mysql-adapter/readme.md)




### Принципы стека LIFO

Стек LIFO (Last In, First Out) — это структура данных, в которой последний добавленный элемент извлекается первым. Основные операции со стеком включают:
- **push**: добавление элемента в конец стека.
- **pop**: удаление и извлечение последнего добавленного элемента.

#### Пример использования стека LIFO

```
// Добавление строки в файл (имитируем push)
file_insert_line('stack.data', "новая строка");

// Извлечение последней строки из файла (pop)
$lastLine = file_pop_line('stack.data');
echo "Извлеченная строка: " . $lastLine;
```

### Сферы применения стека LIFO
Стек LIFO широко используется в различных областях:
- **Алгоритмы**: рекурсивные алгоритмы, обратный польский нотация (RPN).

- **Парсеры**: синтаксический анализатор выражений.
- **Системы управления памятью**: управление стеком вызовов функций.
- **История браузера**: навигация назад/вперед.


#### Межпроцессное взаимодействие (IPC)

Для межпроцессного взаимодействия (IPC) можно использовать файл как общий ресурс, к которому имеют доступ несколько процессов. Каждый процесс может добавлять строки в файл (push) или извлекать строки из файла (pop).



Межпроцессное взаимодействие (IPC) в контексте PHP и файловой системы представляет собой метод обмена данными между процессами, выполняющимися на одной или нескольких машинах. В PHP, несмотря на отсутствие встроенных механизмов IPC, можно использовать различные подходы для реализации взаимодействия между процессами. Один из таких подходов — использование файловой системы как посредника для передачи данных.

#### Основные концепции IPC в PHP

1. **Файловая система как общий ресурс**: Файлы могут служить общим ресурсом для нескольких процессов. Процессы могут читать и записывать данные в файлы, что позволяет им обмениваться информацией.

2. **Синхронизация доступа**: Для предотвращения гонок данных и обеспечения целостности данных требуется синхронизация доступа к файлам. Это может быть достигнуто с помощью блокировок файлов (file locking).

3. **Буферизация и кэширование**: Важно учитывать уровни кэширования и буферизации, предоставляемые операционной системой, чтобы обеспечить корректное и эффективное взаимодействие между процессами.

### Уровни кэширования ядра Linux

1. **Буферизация ввода-вывода (I/O buffering)**: Linux использует буферизацию для уменьшения количества прямых операций ввода-вывода. Данные сначала записываются в буферы в памяти, а затем асинхронно записываются на диск.

2. **Кэширование страниц (Page Cache)**: Это механизм, при котором содержимое файлов кэшируется в оперативной памяти для ускорения доступа. При чтении файла данные сначала ищутся в кэше страниц, что позволяет избежать медленных операций чтения с диска.

3. **Журналирование файловой системы (Filesystem Journaling)**: Некоторые файловые системы, такие как ext4, используют журналирование для обеспечения целостности данных. Журналирование помогает восстановить состояние файловой системы после сбоев.

### Реализация стека LIFO и функции file_pop_line

Для реализации стека LIFO с использованием файловой системы можно использовать файл как контейнер для данных стека. Функция file_pop_line позволяет извлекать последнюю строку из файла и удалять её, что соответствует операции pop в стеке LIFO.

##### Технологические аспекты:

1. **Запись данных (Push)**:
   - Процесс добавляет строку в конец файла.
   - Используется функция file_insert_line, с автоматическим добавлением символа перевода строки.
   - Используется блокировка файла (flock) для предотвращения гонок данных.

2. **Извлечение данных (Pop)**:
   - Функция file_pop_line открывает файл и читает его содержимое.
   - Последняя строка извлекается и удаляется из файла.
   - Для эффективности может использоваться буферизация чтения.
   - После извлечения строки файл усекается на размер последней строки.
   - Блокировка файла также может быть использована для предотвращения одновременного доступа.

3. **Синхронизация и атомарность**:
   - Блокировка файла (flock) обеспечивает атомарность операций записи и чтения.
   - Важно правильно обрабатывать ошибки блокировки и повторять попытки при необходимости.

4. **Кэширование и буферизация**:
   - При записи данных в файл операционная система использует буферы для временного хранения данных перед их записью на диск.
   - Чтение данных сначала происходит из кэша страниц, что ускоряет доступ.


#### Преимущества и недостатки подхода

**Преимущества:**
- Простота реализации: Использование файловой системы не требует дополнительных библиотек или расширений.
- Портативность: Решение работает на всех UNIX подобных системах, поддерживающих PHP и файловую систему.

**Недостатки:**
- Производительность: Операции ввода-вывода на диске могут быть медленными по сравнению с другими методами IPC (например, сокетами или разделяемой памятью).
- Сложности синхронизации: Требуется тщательная обработка блокировок для предотвращения гонок данных.




### Оптимизация на всех уровнях кэширования

#### Кэширование на уровне ядра Linux
Использование системных вызовов позволяет эффективно работать с файлами, используя кэширование на уровне ядра Linux. Это обеспечивает высокую производительность при работе с файлами.

#### Буферизация
Функция использует буферизацию для чтения файла блоками, что уменьшает количество системных вызовов и повышает производительность. Буферизация также помогает минимизировать использование оперативной памяти.

#### Оптимизация памяти
Использование динамического выделения памяти позволяет эффективно управлять памятью и избегать излишнего потребления ресурсов.

### Быстродействие функции со стеком LIFO

Функция `file_pop_line` оптимизирована для работы с файлами любого размера. Использование буферизации и эффективное управление памятью позволяет достичь высокой скорости выполнения операций.

### Системные преимущества
- **Низкое потребление памяти**: благодаря динамическому выделению памяти.
- **Высокая производительность**: за счет использования кэширования на уровне ядра и буферизации.
- **Гибкость**: возможность работы с файлами любого размера.
- **Надежность**: обработка ошибок и защита от утечек памяти.


### Сфера применения стека LIFO для реализации алгоритма мультиплексирования/демултиплексирования порций данных с использованием file_pop_line

Стек LIFO (Last-In-First-Out) может быть полезен в различных сценариях, где требуется мультиплексирование и демультиплексирование данных. Мультиплексирование означает объединение нескольких потоков данных в один, а демультиплексирование — обратный процесс, разделение одного потока данных на несколько.

#### Примеры применения:

1. **Обработка логов и событий в реальном времени**:
   - **Мультиплексирование**: Различные процессы или службы могут записывать события в общий файл. Каждый новый лог или событие добавляется в конец файла.
   - **Демультиплексирование**: Несколько процессов могут параллельно обрабатывать эти события, извлекая их из конца файла (используя file_pop_line), что позволяет оперативно реагировать на последние события.

2. **Системы очередей задач**:
   - **Мультиплексирование**: Задачи от разных источников добавляются в конец общего файла-очереди.
   - **Демультиплексирование**: Несколько воркеров извлекают задачи из конца файла и обрабатывают их, что позволяет распределить нагрузку и ускорить выполнение задач.

3. **Системы обработки данных и ETL (Extract, Transform, Load)**:
   - **Мультиплексирование**: Данные из различных источников (например, базы данных, файлы) записываются в общий файл для последующей обработки.
   - **Демультиплексирование**: Несколько процессов параллельно извлекают данные из файла для выполнения ETL-операций, таких как очистка, трансформация и загрузка данных в целевую систему.

4. **Системы кэширования и буферизации**:
   - **Мультиплексирование**: Новые данные или результаты вычислений добавляются в конец файла-кэша.
   - **Демультиплексирование**: При необходимости чтения данных из кэша, процессы извлекают последние добавленные элементы, что может быть полезно в сценариях, где последние данные более актуальны.

5. **Системы мониторинга и алертинга**:
   - **Мультиплексирование**: Различные агенты мониторинга записывают метрики и события в общий файл.
   - **Демультиплексирование**: Процессы обработки алертов извлекают последние метрики и события для анализа и генерации уведомлений.


#### Важные аспекты:

1. **Синхронизация доступа**:
   - Каждый процесс использует блокировку файла (`flock`) при вызове функции `file_pop_line`, чтобы избежать одновременного доступа к файлу несколькими процессами.
   - Блокировка освобождается после завершения операции чтения и удаления строки из файла.

2. **Атомарность операций**:
   - Операции чтения и удаления строки из файла должны быть атомарными, чтобы избежать гонок данных.
   - Это достигается за счет использования блокировок и правильной обработки ошибок.

3. **Эффективность**:
   - Использование нескольких процессов позволяет эффективно распределять нагрузку по нескольким ядрам процессора.
   - Буферизация и кэширование операционной системы ускоряют операции чтения и записи.



### Пример реализации логики программного worker для загрузки url

Программный worker — это процесс, который выполняет определенную задачу, такую как обработка данных из стека LIFO. В данном случае worker будет извлекать URL из стека, скачивать содержимое по этому URL и выполнять сложный анализ или парсинг контента.

Пример создан по мотивам функции queue_address_manager в проекте [php cron requests events](https://github.com/commeta/php-cron-requests-events) файл cron.php


#### Логика работы worker:

1. **Инициализация**: Worker запускается и подготавливается к работе.
2. **Цикл обработки**:
   - Worker вызывает функцию file_pop_line для извлечения последнего URL из файла.
   - Если URL успешно извлечен, worker выполняет скачивание содержимого по этому URL.
   - После скачивания содержимого worker выполняет анализ или парсинг контента.
   - Worker повторяет цикл до тех пор, пока в файле остаются URL для обработки.

#### Совместная работа нескольких параллельных процессов с очередью LIFO

##### Сценарий:

1. **Процесс создания очереди**:
   - Один процесс (process_id: 1) создает длинную очередь URL для скачивания.
   - Процесс добавляет в конец файла много строк, каждая из которых содержит URL.

2. **Процессы обработки**:
   - Несколько процессов (process_id: 2, 3, 4, 5) работают параллельно.
   - Каждый процесс в цикле вызывает функцию file_pop_line для извлечения последнего элемента стека.
   - Процесс скачивает содержимое по извлеченному URL.
   - Процесс выполняет сложный анализ или парсинг контента.
   - Таким образом, работа распределяется по нескольким ядрам процессора (при CPU BOUND задачах) или выстраевается в очередь с длинным циклом ожидания скачивания данных (IO BOUND).



### Блокировки в Linux

Файл /proc/locks в Linux содержит информацию о всех файловых блокировках, установленных в системе. Этот файл является частью виртуальной файловой системы /proc, которая предоставляет интерфейс для взаимодействия с ядром и получения информации о состоянии системы.

Каждая строка в /proc/locks описывает одну блокировку и содержит несколько полей, разделенных пробелами. Поля на примере строки:
```
$db_file = __DIR__ . '/fast_io.dat';
file_insert_line($db_file, ' ');
file_callback_line(
	$db_file,
	function () {
		$locks = explode("\n", file_get_contents("/proc/locks"));
		$p_id = getmypid();

		foreach($locks as $lock){
			$records = explode(" ", $lock);
			if(isset($records[6]) && $records[6] == $p_id) {
				print_r($records);
			}
		}

		return false;
	}
);

Array
(
    [0] => 31:
    [1] => FLOCK
    [2] => 
    [3] => ADVISORY
    [4] => 
    [5] => WRITE
    [6] => 1542032
    [7] => fc:01:4760679
    [8] => 0
    [9] => EOF
)
```

#### Поля в /proc/locks

1. **31:** Номер блокировки. Это уникальный идентификатор для каждой блокировки.
2. **FLOCK:** Тип блокировки. Возможные значения:
   - FLOCK: Блокировка, установленная с помощью системного вызова flock.
   - POSIX: Блокировка, установленная с помощью системного вызова fcntl (POSIX-совместимая).
   - LEASE: Означает арендную блокировку (lease lock).
3. **ADVISORY:** Режим блокировки. Возможные значения:
   - ADVISORY: Советующая блокировка (необязательная), которая зависит от согласования между процессами.
   - MANDATORY: Обязательная блокировка, которая принудительно применяется ко всем операциям ввода-вывода.
4. **WRITE:** Тип доступа. Возможные значения:
   - READ: Блокировка на чтение.
   - WRITE: Блокировка на запись.
5. **1542032:** PID процесса, который установил блокировку.
6. **fc:01:4760679:** Идентификатор файла, который заблокирован. Этот идентификатор состоит из трех частей:
   - fc: Мажорный номер устройства.
   - 01: Минорный номер устройства.
   - 4760679: Номер inode файла.
7. **0:** Начало диапазона блокировки (смещение в байтах от начала файла).
8. **EOF:** Конец диапазона блокировки (EOF указывает на конец файла).


Для более глубокого понимания реализации файловых блокировок в ядре Linux рассмотрите исходный код из файла locks.c на GitHub по ссылке [fs/locks.c](https://github.com/torvalds/linux/blob/master/fs/locks.c).





### Параметры настройки системы (sysctl)

Настройки ядра и параметры конфигурации могут существенно влиять на поведение файловых блокировок и операций ввода-вывода в Linux. Понимание этих настроек и их правильная конфигурация может помочь оптимизировать производительность и надежность.

Некоторые параметры можно настроить с помощью утилиты sysctl, которая позволяет изменять параметры времени выполнения ядра Linux.

1. **vm.dirty_ratio**: Процент памяти системы, который может быть занят грязными страницами (данные, которые были изменены в памяти, но еще не записаны на диск).
   
   sysctl -w vm.dirty_ratio=20
   

2. **vm.dirty_background_ratio**: Процент памяти, который может быть занят грязными страницами до того, как фоновые процессы начнут сбрасывать их на диск.
   
   sysctl -w vm.dirty_background_ratio=10
   

3. **vm.dirty_writeback_centisecs**: Интервал времени (в сотых долях секунды), через который фоновые процессы сбрасывают грязные страницы на диск.
   
   sysctl -w vm.dirty_writeback_centisecs=500
   

4. **vm.dirty_expire_centisecs**: Время (в сотых долях секунды), через которое страницы считаются старыми и должны быть сброшены на диск.
   
   sysctl -w vm.dirty_expire_centisecs=3000
   

#### Настройки файловой системы

Некоторые параметры монтирования файловой системы могут также влиять на поведение блокировок и операций ввода-вывода.

1. **noatime**: Отключает обновление времени доступа к файлам при чтении, что может улучшить производительность.
   
   mount -o noatime /dev/sda1 /mnt
   

2. **nodiratime**: Отключает обновление времени доступа для каталогов.
   
   mount -o nodiratime /dev/sda1 /mnt
   

3. **data=writeback|ordered|journal**: Определяет режим ведения журнала данных для файловой системы ext3/ext4.
   - writeback: Данные могут быть записаны после обновления метаданных, что может привести к лучшей производительности, но снижает целостность данных.
   - ordered: Данные записываются перед обновлением метаданных (по умолчанию).
   - journal: Все данные и метаданные записываются в журнал, что обеспечивает максимальную целостность данных, но снижает производительность.
   
   
   mount -o data=ordered /dev/sda1 /mnt
   



