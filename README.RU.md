# Fast_IO - Расширение для PHP 8 (BETA)

## Описание

Fast_IO - это высокопроизводительное расширение для PHP 8, разработанное для эффективной работы с файлами данных. Оно предлагает набор функций для чтения, записи, обновления и удаления пар ключ-значение в файлах данных, используя низкоуровневый посекторный доступ и механизмы блокировки для синхронизации доступа. Это расширение идеально подходит для работы с большими объемами данных, обеспечивая высокую скорость и эффективность операций благодаря оптимизированному управлению памятью и дисковым вводом-выводом.

## Основные возможности

- **Быстрая запись и чтение**: Позволяет выполнять операции записи и чтения для строк с высокой производительностью.
- **Транзакции с блокировкой**: Использует механизм портируемой блокировки файла для обеспечения синхронизации доступа между параллельными операциями.
- **Эффективное управление памятью**: Чтение данных осуществляется порциями, что предотвращает переполнение памяти при работе с большими файлами.
- **Поддержка индексных файлов**: Улучшает производительность поиска по ключу за счет использования отдельных индексных файлов.
- **Бинарная безопасность**: Функции с постфиксом data обеспечивают безопасную работу с бинарными данными.

## Функции расширения
- [file_push_line](/docs/file_push_line.md) - Добавление строки в текстовый файл.
- [file_pop_line](/docs/file_pop_line.md) - Извлечение и удаление последней строки из файла.
- [file_defrag_data](/docs/file_defrag_data.md) - Дефрагментация файла данных и соответствующего индексного файла.
- [file_push_data](/docs/file_push_data.md) - Добавление порции бинарных данных файл данных и соответствующий индексный файл.
- [file_search_data](/docs/file_search_data.md) - Поиск порции бинарных данных по ключу, с использованием индексного файла.
- [file_erase_line](/docs/file_erase_line.md) - Стереть строку файле данных.
- [file_search_line](/docs/file_search_line.md) - Поиск строки по ключу в файле данных, возвращает строку.
- [file_search_array](/docs/file_search_array.md) - Поиск строк по ключу в файле данных, возвращает массив.
- [file_defrag_lines](/docs/file_defrag_lines.md) - Удаление строк из файла данных.
- [file_get_keys](/docs/file_get_keys.md) - Извлечение уникальных ключей из текстового файла.
- [file_replace_line](/docs/file_replace_line.md) - Замена строки по ключу.
- [file_insert_line](/docs/file_insert_line.md) - Вставка строк с выравниванием в файл.
- [file_select_line](/docs/file_select_line.md) - Выборка строки из файла, по указанному номеру или смещению.
- [file_update_line](/docs/file_update_line.md) - Обновление строки в файле.
- [file_analize](/docs/file_analize.md) - Возвращает максимальную длину строки в файле.
- [replicate_file](/docs/replicate_file.md) - Репликация файла данных.


## Особенности реализации

- Все функции используют UNIX портируемую блокировку файла на запись, что гарантирует целостность данных при параллельном доступе [алгоритм реализации транзакции с помощью блокировки файла](/test/transaction/README.md).
- Расширение разработано без использования сторонних фреймворков и библиотек, обеспечивая высокую производительность и совместимость с PHP 8.
- Функции производят чтение данных порциями, оптимизируя использование памяти и уменьшая нагрузку на систему.
- Стоимость вызовов функций с низким потреблением в случае попадания в кэш, сопоставима со скоростью доступа к кэш памяти.

Fast_IO представляет собой мощное расширение для PHP 8, которое значительно упрощает и ускоряет работу с большими объемами данных. Благодаря эффективным механизмам чтения, записи, блокировки и управления памятью, разработчики могут создавать высокопроизводительные приложения, оптимизированные для обработки файлов данных.

## Примеры использования

Для каждой функции расширения Fast_IO предоставлены подробные описания с примерами на PHP. Эти примеры помогут разработчикам быстро начать работу с расширением и эффективно использовать его возможности в своих проектах.

## Параметры

buffer_size - это параметр конфигурации, определяющий размер буфера для операций чтения\записи. Указание оптимального размера буфера может значительно улучшить производительность при работе с большими объемами данных.

#### Установка через php.ini

Для настройки размера буфера в глобальной конфигурации PHP добавьте или измените следующую строку в файле php.ini:

fast_io.buffer_size = 4096 // От 16 байт

Значение указывается в байтах. По умолчанию размер буфера установлен равным 4096 байт (4 КБ).

#### Использование в коде PHP

Вы можете получить текущее значение buffer_size или установить новое значение в начале вашего PHP скрипта:
```
// Получить текущий размер буфера
$currentBufferSize = ini_get('fast_io.buffer_size');

// Установить новый размер буфера, до вызова функций!
ini_set('fast_io.buffer_size', 8192); // 8 КБ
```

#### Инициализация

Инициализация параметров в PHP происходит во время запуска сервера или выполнения скрипта. В приведенном примере кода инициализация параметра "fast_io.buffer_size" осуществляется при инициализации модуля fast_io в PHP.

### Примечания

- Изменение размера буфера во время выполнения скрипта может повлиять на производительность операций ввода-вывода, выполняемых после этого изменения.
- Выбор оптимального размера буфера зависит от конкретных задач и условий работы приложения. Рекомендуется проводить тестирование с различными значениями, чтобы найти наилучший вариант.
- Указывайте размер буфера ориентируясь на размер порции данных, значения по умолчанию 4096 достаточно для работы со строками размером 4096 байт.
- При большом размере буфера возможны лишние чтения файла, например при полнотекстовом поиске, когда значение может быть найдено в начале файла, а он будет прочитан на величину буфера.
- В операциях поиска строк создается динамический буфер dynamic_buffer по принципу dynamic_buffer += buffer_size.
- Если размер файла меньше buffer_size, то buffer_size уменьшается до размера файла.


dynamic_buffer используется для хранения частей файла, считываемых в память для поиска определенного ключа или выполнения сопоставления с регулярным выражением. Работа dynamic_buffer основана на следующих принципах:

### Как Работает dynamic_buffer

1. **Инициализация и Размер**: Буфер инициализируется с начальным размером, определенным значением fast_io.buffer_size.

2. **Чтение из Файла**: Данные считываются из файла блоками размером fast_io.buffer_size и добавляются в dynamic_buffer. В режиме поиска строк, если строка не помещается в текущий размер буфера, dynamic_buffer увеличивается на размер fast_io.buffer_size на каждой итерации чтения из файла.

3. **Увеличение Размера**: Размер dynamic_buffer увеличивается на ini_buffer_size. Увеличение происходит с помощью функции erealloc, которая пытается изменить размер уже выделенной памяти, сохраняя при этом существующие данные.


### Использование системного буфера C

Когда вы работаете с файловыми операциями, такими как чтение из файла с помощью буферных функции, используется системный буфер. Этот буфер служит промежуточным хранилищем данных между физическим файлом на диске и оперативной памятью компьютера. Системный буфер позволяет оптимизировать ввод-вывод за счет минимизации количества обращений к диску, что значительно увеличивает производительность операций чтения и записи.

В процессе работы системный буфер используется для временного хранения данных, считанных из файла, перед тем как они будут помещены в пользовательский буфер (dynamic_buffer). Это позволяет эффективно читать данные большими блоками, что уменьшает количество обращений к диску.

### Преимущества использования системного буфера C

1. **Эффективность**: Чтение данных большими блоками и их временное хранение в системном буфере уменьшает нагрузку на дисковую систему и повышает общую производительность операций ввода-вывода.

2. **Уменьшение Задержек**: Минимизация обращений к диску снижает задержки, связанные с механическими особенностями работы жестких дисков и особенностями работы солид-стейт дисков (SSD).


### Использование системного кэша ядра Linux

Когда функция запрашивает данные из файла, системный кэш ядра Linux играет ключевую роль в оптимизации производительности при обращении к данным на диске.

### Как работает системный кэш ядра Linux:

1. **Чтение данных**: Когда функция пытается прочитать данные из файла, операционная система сначала проверяет, находятся ли эти данные в системном кэше (кэше страниц ядра). Если данные уже есть в кэше, они могут быть немедленно предоставлены процессу без необходимости обращения к физическому диску.

2. **Кэширование данных**: Если запрашиваемые данные отсутствуют в кэше, ядро загружает эти данные с диска в системный кэш перед их предоставлением процессу. При этом, данные загружаются блоками, что повышает эффективность последующих обращений к этим же данным.

3. **Запись данных**: При записи данных в файл, данные сначала помещаются в системный кэш, и только потом, в зависимости от политики кэширования и активности системы, они могут быть записаны на физический носитель. Это позволяет уменьшить количество операций записи на диск, что положительно сказывается на сроке службы диска и производительности системы.

### Преимущества использования системного кэша:

- **Уменьшение задержек**: Доступ к данным из кэша значительно быстрее доступа к данным с физического диска, что уменьшает время выполнения операций чтения/записи.
- **Оптимизация работы с диском**: Кэширование позволяет сократить количество обращений к диску за счет предварительного чтения и отложенной записи, что повышает общую производительность системы.
- **Повышение пропускной способности**: Системный кэш позволяет обрабатывать больше операций ввода-вывода за единицу времени благодаря уменьшению количества фактических обращений к диску.

Использование системного кэша ядра Linux помогает ускорить процесс поиска значений в файле, особенно если файл часто используется или его размер превышает размер оперативной памяти. Это делает чтение данных более эффективным и уменьшает общее время выполнения функции.


### Упреждающее чтение (Read-Ahead)

Упреждающее чтение — это метод, используемый операционными системами и файловыми системами, для увеличения производительности чтения данных с диска. ОС заранее читает с диска больше данных, чем было запрошено приложением, предполагая, что эти данные скоро понадобятся. Это уменьшает количество обращений к диску и увеличивает скорость чтения данных.

При чтении данных упреждающее чтение может быть неявно использовано через механизмы ОС и файловой системы, когда вы выполняете запрос для чтения блоков данных из файла. ОС может заранее загружать данные в системный буфер, ускоряя доступ к последующим блокам данных.

### Оптимизация записи на диск

**Задержанная запись (Write-Back Caching)**: При записи данных они сначала помещаются в буфер (кэш) в памяти, а не сразу записываются на диск. Запись на физический носитель происходит позже, в более удобное время. Это уменьшает количество операций записи на диск, что положительно сказывается на производительности и сроке службы диска.


---

## Установка

### Шаг 1: Создание каркаса расширения
Скопируйте файлы: `config.m4`, `fast_io.c`, `fast_io.h` в текущий каталог проекта.

Для начала, вам нужно создать каркас вашего расширения. Это можно сделать вручную или с помощью инструмента ext_skel в исходниках PHP. Например:
```
phpize
./configure
make
make test
```

Это создаст базовую структуру для вашего расширения.



### Шаг 2: Компиляция и тестирование

Вам нужно скомпилировать расширение и протестировать его. Используйте phpize, ./configure, make и make test для компиляции и установки вашего расширения.

После установки не забудьте добавить строку `extension=fast_io.so` в ваш `php.ini`, чтобы активировать расширение.

Теперь вы можете вызывать новые функции из PHP как обычные функции.

Результат тестирования: Ubuntu 24.04, Ryzen 12 Cores, 16GB RAM, SATA 3 SSD.

```
file_push_line: 0.13037991523743 (0.00001304)
file_search_line: 2.8793230056763 (0.00028793)
file_search_line repeat: 0.091537952423096 (0.00000915)
file_defrag_lines: 0.87505483627319 (0.00008751)
file_push_data: 0.23846697807312 (0.00002385)
file_search_data: 2.5550649166107 (0.00025551)
file_search_data repeat: 0.17655897140503 (0.00001766)
file_pop_line: 0.3167359828949 (0.00003167)
```

Функция запускалась в цикле 10000 раз, с линейным инкрементом индекса (без попадания в кэш) и repeat многократный поиск одного и того же индекса.
Показано время в секундах по результатам теста: 10000 запусков (1 запуск).

## Стоимость вызовов

Таблица стоимости вызова функции по возрастанию:

- file_select_line Очень низкое потребление, посекторное чтение отрезка файла.
- file_update_line Очень низкое потребление, посекторная запись отрезка файла.
- file_pop_line Низкое потребление, с выравниванием очень низкое, чтение файла с конца, усечение файла.
- file_push_line Очень низкое потребление, запись строки в конец файла.
- file_insert_line Очень низкое потребление, запись строки в конец файла.
- file_push_data Низкое потребление, запись строки в конец файла индекса и блока в конец файла данных.
- file_search_line Среднее потребление, чтение всего файла.
- file_search_array Среднее потребление, чтение всего файла.
- file_analize Среднее потребление, чтение всего файла.
- file_get_keys Среднее потребление, чтение всего файла.
- file_erase_line Среднее потребление, чтение всего файла, запись строки в файл.
- file_search_data Среднее потребление, чтение всего файла индекса и блока файла данных.
- file_defrag_lines Очень высокое потребление, полное чтение\запись всего файла.
- file_replace_line Очень высокое потребление, полное чтение\запись всего файла.
- file_defrag_data Очень высокое потребление, полное чтение\запись файлов индекса и данных.

#### Примеры

- [Тесты](test/readme.md)
- [Пример SQL адаптера](test/mysql-adapter/readme.md)
